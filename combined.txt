package tenant

import (
	"net/http"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
)

// ============================================================================
// Tenant Entity
// ============================================================================

// TenantStatus define los posibles estados de un tenant
type TenantStatus string

const (
	TenantStatusActive    TenantStatus = "ACTIVE"
	TenantStatusSuspended TenantStatus = "SUSPENDED"
	TenantStatusCanceled  TenantStatus = "CANCELED"
	TenantStatusTrial     TenantStatus = "TRIAL"
)

// SubscriptionPlan define los planes de suscripción
type SubscriptionPlan string

const (
	PlanTrial        SubscriptionPlan = "TRIAL"
	PlanBasic        SubscriptionPlan = "BASIC"
	PlanProfessional SubscriptionPlan = "PROFESSIONAL"
	PlanEnterprise   SubscriptionPlan = "ENTERPRISE"
)

// Tenant es la entidad rica que representa una empresa en el sistema
type Tenant struct {
	ID                    kernel.TenantID  `db:"id" json:"id"`
	CompanyName           string           `db:"company_name" json:"company_name"`
	Status                TenantStatus     `db:"status" json:"status"`
	SubscriptionPlan      SubscriptionPlan `db:"subscription_plan" json:"subscription_plan"`
	MaxUsers              int              `db:"max_users" json:"max_users"`
	CurrentUsers          int              `db:"current_users" json:"current_users"`
	TrialExpiresAt        *time.Time       `db:"trial_expires_at" json:"trial_expires_at,omitempty"`
	SubscriptionExpiresAt *time.Time       `db:"subscription_expires_at" json:"subscription_expires_at,omitempty"`

	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

// ============================================================================
// Domain Methods
// ============================================================================

// IsActive verifica si el tenant está activo
func (t *Tenant) IsActive() bool {
	return t.Status == TenantStatusActive
}

// IsTrial verifica si el tenant está en período de prueba
func (t *Tenant) IsTrial() bool {
	return t.SubscriptionPlan == PlanTrial || t.Status == TenantStatusTrial
}

// IsTrialExpired verifica si el trial ha expirado
func (t *Tenant) IsTrialExpired() bool {
	if !t.IsTrial() || t.TrialExpiresAt == nil {
		return false
	}
	return time.Now().After(*t.TrialExpiresAt)
}

// IsSubscriptionExpired verifica si la suscripción ha expirado
func (t *Tenant) IsSubscriptionExpired() bool {
	if t.SubscriptionExpiresAt == nil {
		return false
	}
	return time.Now().After(*t.SubscriptionExpiresAt)
}

// CanAddUser verifica si se puede agregar un nuevo usuario
func (t *Tenant) CanAddUser() bool {
	if !t.IsActive() {
		return false
	}
	if t.IsTrialExpired() || t.IsSubscriptionExpired() {
		return false
	}
	return t.CurrentUsers < t.MaxUsers
}

// AddUser incrementa el contador de usuarios
func (t *Tenant) AddUser() error {
	if !t.CanAddUser() {
		return ErrMaxUsersReached().WithDetail("max_users", t.MaxUsers).WithDetail("current_users", t.CurrentUsers)
	}

	t.CurrentUsers++
	t.UpdatedAt = time.Now()
	return nil
}

// RemoveUser decrementa el contador de usuarios
func (t *Tenant) RemoveUser() {
	if t.CurrentUsers > 0 {
		t.CurrentUsers--
		t.UpdatedAt = time.Now()
	}
}

// Suspend suspende el tenant
func (t *Tenant) Suspend(reason string) {
	t.Status = TenantStatusSuspended
	t.UpdatedAt = time.Now()
}

// Activate activa el tenant
func (t *Tenant) Activate() {
	t.Status = TenantStatusActive
	t.UpdatedAt = time.Now()
}

// UpgradePlan mejora el plan de suscripción
func (t *Tenant) UpgradePlan(newPlan SubscriptionPlan) error {
	maxUsers := t.getMaxUsersForPlan(newPlan)
	if t.CurrentUsers > maxUsers {
		return ErrTooManyUsersForPlan().WithDetail("current_users", t.CurrentUsers).WithDetail("max_allowed", maxUsers)
	}

	t.SubscriptionPlan = newPlan
	t.MaxUsers = maxUsers
	t.UpdatedAt = time.Now()
	return nil
}

// getMaxUsersForPlan retorna el máximo de usuarios para un plan
func (t *Tenant) getMaxUsersForPlan(plan SubscriptionPlan) int {
	switch plan {
	case PlanTrial, PlanBasic:
		return 5
	case PlanProfessional:
		return 50
	case PlanEnterprise:
		return 500
	default:
		return 1
	}
}

// ============================================================================
// DTOs
// ============================================================================

// TenantDetailsDTO contiene información básica de un tenant para otros módulos
type TenantDetailsDTO struct {
	ID               kernel.TenantID  `json:"id"`
	CompanyName      string           `json:"company_name"`
	Status           TenantStatus     `json:"status"`
	SubscriptionPlan SubscriptionPlan `json:"subscription_plan"`
	MaxUsers         int              `json:"max_users"`
	CurrentUsers     int              `json:"current_users"`
}

// ToDTO convierte la entidad Tenant a TenantDetailsDTO
func (t *Tenant) ToDTO() TenantDetailsDTO {
	return TenantDetailsDTO{
		ID:               t.ID,
		CompanyName:      t.CompanyName,
		Status:           t.Status,
		SubscriptionPlan: t.SubscriptionPlan,
		MaxUsers:         t.MaxUsers,
		CurrentUsers:     t.CurrentUsers,
	}
}

// ============================================================================
// Service DTOs - Para operaciones de la capa de servicio
// ============================================================================

// CreateTenantRequest representa la petición para crear un tenant
type CreateTenantRequest struct {
	CompanyName      string           `json:"company_name" validate:"required,min=2"`
	SubscriptionPlan SubscriptionPlan `json:"subscription_plan"`
}

// UpdateTenantRequest representa la petición para actualizar un tenant
type UpdateTenantRequest struct {
	CompanyName *string       `json:"company_name,omitempty" validate:"omitempty,min=2"`
	Status      *TenantStatus `json:"status,omitempty"`
}

// TenantResponse representa la respuesta completa de un tenant con configuración
type TenantResponse struct {
	Tenant Tenant            `json:"tenant"`
	Config map[string]string `json:"config"`
}

// ToDTO convierte TenantResponse a TenantResponseDTO
func (tr *TenantResponse) ToDTO() TenantResponseDTO {
	return TenantResponseDTO{
		Tenant: tr.Tenant.ToDTO(),
		Config: tr.Config,
	}
}

// TenantResponseDTO es la versión DTO de TenantResponse
type TenantResponseDTO struct {
	Tenant TenantDetailsDTO  `json:"tenant"`
	Config map[string]string `json:"config"`
}

// SuspendTenantRequest para suspender un tenant
type SuspendTenantRequest struct {
	Reason string `json:"reason" validate:"required,min=10"`
}

// ActivateTenantRequest para activar un tenant
type ActivateTenantRequest struct {
	Comments string `json:"comments,omitempty"`
}

// UpgradePlanRequest para cambiar el plan de suscripción
type UpgradePlanRequest struct {
	NewPlan SubscriptionPlan `json:"new_plan" validate:"required"`
}

// SetConfigRequest para establecer una configuración
type SetConfigRequest struct {
	Key   string `json:"key" validate:"required"`
	Value string `json:"value" validate:"required"`
}

// DeleteConfigRequest para eliminar una configuración
type DeleteConfigRequest struct {
	Key string `json:"key" validate:"required"`
}

// TenantListResponse para listas de tenants
type TenantListResponse struct {
	Tenants []TenantResponse `json:"tenants"`
	Total   int              `json:"total"`
}

// ToDTO convierte TenantListResponse a TenantListResponseDTO
func (tlr *TenantListResponse) ToDTO() TenantListResponseDTO {
	var tenantsDTO []TenantResponseDTO
	for _, t := range tlr.Tenants {
		tenantsDTO = append(tenantsDTO, t.ToDTO())
	}

	return TenantListResponseDTO{
		Tenants: tenantsDTO,
		Total:   tlr.Total,
	}
}

// TenantListResponseDTO es la versión DTO de TenantListResponse
type TenantListResponseDTO struct {
	Tenants []TenantResponseDTO `json:"tenants"`
	Total   int                 `json:"total"`
}

// TenantStatsResponse para estadísticas del tenant
type TenantStatsResponse struct {
	TenantID              kernel.TenantID `json:"tenant_id"`
	TotalUsers            int             `json:"total_users"`
	ActiveUsers           int             `json:"active_users"`
	MaxUsers              int             `json:"max_users"`
	UserUtilization       float64         `json:"user_utilization"` // Porcentaje de usuarios usados
	SubscriptionStatus    string          `json:"subscription_status"`
	DaysUntilExpiration   *int            `json:"days_until_expiration,omitempty"`
	IsTrialExpired        bool            `json:"is_trial_expired"`
	IsSubscriptionExpired bool            `json:"is_subscription_expired"`
}

// TenantHealthResponse para el estado de salud del tenant
type TenantHealthResponse struct {
	TenantID        kernel.TenantID `json:"tenant_id"`
	Status          TenantStatus    `json:"status"`
	IsHealthy       bool            `json:"is_healthy"`
	Issues          []string        `json:"issues,omitempty"`
	LastHealthCheck time.Time       `json:"last_health_check"`
}

// BulkTenantOperationRequest para operaciones masivas
type BulkTenantOperationRequest struct {
	TenantIDs []kernel.TenantID `json:"tenant_ids" validate:"required,min=1"`
	Operation string            `json:"operation" validate:"required,oneof=suspend activate delete"`
	Reason    string            `json:"reason,omitempty"`
}

// BulkTenantOperationResponse resultado de operaciones masivas
type BulkTenantOperationResponse struct {
	Successful []kernel.TenantID          `json:"successful"`
	Failed     map[kernel.TenantID]string `json:"failed"`
	Total      int                        `json:"total"`
}

// TenantConfigResponse para respuestas de configuración
type TenantConfigResponse struct {
	TenantID kernel.TenantID   `json:"tenant_id"`
	Config   map[string]string `json:"config"`
}

// TenantUsageResponse para información de uso del tenant
type TenantUsageResponse struct {
	TenantID        kernel.TenantID `json:"tenant_id"`
	CurrentUsers    int             `json:"current_users"`
	MaxUsers        int             `json:"max_users"`
	UsagePercentage float64         `json:"usage_percentage"`
	CanAddUsers     bool            `json:"can_add_users"`
	RemainingUsers  int             `json:"remaining_users"`
}

// ============================================================================
// Error Registry - Errores específicos de Tenant
// ============================================================================

var ErrRegistry = errx.NewRegistry("TENANT")

// Códigos de error
var (
	CodeTenantNotFound      = ErrRegistry.Register("NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Empresa no encontrada")
	CodeTenantAlreadyExists = ErrRegistry.Register("ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "La empresa ya existe")
	CodeTenantSuspended     = ErrRegistry.Register("SUSPENDED", errx.TypeBusiness, http.StatusForbidden, "Empresa suspendida")
	CodeTrialExpired        = ErrRegistry.Register("TRIAL_EXPIRED", errx.TypeBusiness, http.StatusPaymentRequired, "Período de prueba expirado")
	CodeSubscriptionExpired = ErrRegistry.Register("SUBSCRIPTION_EXPIRED", errx.TypeBusiness, http.StatusPaymentRequired, "Suscripción expirada")
	CodeMaxUsersReached     = ErrRegistry.Register("MAX_USERS_REACHED", errx.TypeBusiness, http.StatusForbidden, "Máximo de usuarios alcanzado")
	CodeTooManyUsersForPlan = ErrRegistry.Register("TOO_MANY_USERS_FOR_PLAN", errx.TypeBusiness, http.StatusBadRequest, "El nuevo plan no permite tantos usuarios")
	CodeTenantHasUsers      = ErrRegistry.Register("TENANT_HAS_USERS", errx.TypeBusiness, http.StatusConflict, "No se puede eliminar tenant con usuarios activos")
	CodeInvalidPlanUpgrade  = ErrRegistry.Register("INVALID_PLAN_UPGRADE", errx.TypeBusiness, http.StatusBadRequest, "Actualización de plan inválida")
)

// Helper functions para crear errores
func ErrTenantNotFound() *errx.Error {
	return ErrRegistry.New(CodeTenantNotFound)
}

func ErrTenantAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeTenantAlreadyExists)
}

func ErrTenantSuspended() *errx.Error {
	return ErrRegistry.New(CodeTenantSuspended)
}

func ErrTrialExpired() *errx.Error {
	return ErrRegistry.New(CodeTrialExpired)
}

func ErrSubscriptionExpired() *errx.Error {
	return ErrRegistry.New(CodeSubscriptionExpired)
}

func ErrMaxUsersReached() *errx.Error {
	return ErrRegistry.New(CodeMaxUsersReached)
}

func ErrTooManyUsersForPlan() *errx.Error {
	return ErrRegistry.New(CodeTooManyUsersForPlan)
}

func ErrTenantHasUsers() *errx.Error {
	return ErrRegistry.New(CodeTenantHasUsers)
}

func ErrInvalidPlanUpgrade() *errx.Error {
	return ErrRegistry.New(CodeInvalidPlanUpgrade)
}
package tenant

import (
	"context"

	"github.com/Abraxas-365/manifesto/pkg/kernel"
)

// TenantRepository define el contrato para la persistencia de tenants
type TenantRepository interface {
	FindByID(ctx context.Context, id kernel.TenantID) (*Tenant, error)
	FindAll(ctx context.Context) ([]*Tenant, error)
	FindActive(ctx context.Context) ([]*Tenant, error)
	Save(ctx context.Context, t Tenant) error
	Delete(ctx context.Context, id kernel.TenantID) error
}

// TenantConfigRepository define el contrato para configuraciones del tenant
type TenantConfigRepository interface {
	FindByTenant(ctx context.Context, tenantID kernel.TenantID) (map[string]string, error)
	SaveSetting(ctx context.Context, tenantID kernel.TenantID, key, value string) error
	DeleteSetting(ctx context.Context, tenantID kernel.TenantID, key string) error
}
package tenantsrv

import (
	"context"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/config"
	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam/tenant"
	"github.com/Abraxas-365/manifesto/pkg/iam/user"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/google/uuid"
)

// TenantService proporciona operaciones de negocio para tenants
type TenantService struct {
	tenantRepo       tenant.TenantRepository
	tenantConfigRepo tenant.TenantConfigRepository
	userRepo         user.UserRepository
	config           *config.TenantConfig
}

// NewTenantService crea una nueva instancia del servicio de tenants
func NewTenantService(
	tenantRepo tenant.TenantRepository,
	tenantConfigRepo tenant.TenantConfigRepository,
	userRepo user.UserRepository,
	config *config.TenantConfig,
) *TenantService {
	return &TenantService{
		tenantRepo:       tenantRepo,
		tenantConfigRepo: tenantConfigRepo,
		userRepo:         userRepo,
		config:           config,
	}
}

// CreateTenant crea un nuevo tenant
func (s *TenantService) CreateTenant(ctx context.Context, req tenant.CreateTenantRequest) (*tenant.Tenant, error) {
	// Crear nuevo tenant
	newTenant := &tenant.Tenant{
		ID:                    kernel.NewTenantID(uuid.NewString()),
		CompanyName:           req.CompanyName,
		Status:                tenant.TenantStatusTrial, // Empieza en trial
		SubscriptionPlan:      tenant.PlanTrial,
		MaxUsers:              s.getMaxUsersForPlan(tenant.PlanTrial),
		CurrentUsers:          0,
		TrialExpiresAt:        s.calculateTrialExpiration(),
		SubscriptionExpiresAt: nil,
		CreatedAt:             time.Now(),
		UpdatedAt:             time.Now(),
	}

	// Si se especificó un plan diferente, usar ese
	if req.SubscriptionPlan != "" {
		newTenant.SubscriptionPlan = req.SubscriptionPlan
		newTenant.MaxUsers = s.getMaxUsersForPlan(req.SubscriptionPlan)
		if req.SubscriptionPlan != tenant.PlanTrial {
			newTenant.Status = tenant.TenantStatusActive
			newTenant.SubscriptionExpiresAt = s.calculateSubscriptionExpiration()
		}
	}

	// Guardar tenant
	if err := s.tenantRepo.Save(ctx, *newTenant); err != nil {
		return nil, errx.Wrap(err, "failed to save tenant", errx.TypeInternal)
	}

	return newTenant, nil
}

// GetTenantByID obtiene un tenant por ID
func (s *TenantService) GetTenantByID(ctx context.Context, tenantID kernel.TenantID) (*tenant.TenantResponse, error) {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	// Obtener configuraciones del tenant
	config, err := s.tenantConfigRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		config = make(map[string]string) // Default a empty config
	}

	return &tenant.TenantResponse{
		Tenant: *tenantEntity,
		Config: config,
	}, nil
}

// GetAllTenants obtiene todos los tenants
func (s *TenantService) GetAllTenants(ctx context.Context) (*tenant.TenantListResponse, error) {
	tenants, err := s.tenantRepo.FindAll(ctx)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get all tenants", errx.TypeInternal)
	}

	var responses []tenant.TenantResponse
	for _, t := range tenants {
		config, _ := s.tenantConfigRepo.FindByTenant(ctx, t.ID)
		if config == nil {
			config = make(map[string]string)
		}
		responses = append(responses, tenant.TenantResponse{
			Tenant: *t,
			Config: config,
		})
	}

	return &tenant.TenantListResponse{
		Tenants: responses,
		Total:   len(responses),
	}, nil
}

// GetActiveTenants obtiene todos los tenants activos
func (s *TenantService) GetActiveTenants(ctx context.Context) (*tenant.TenantListResponse, error) {
	tenants, err := s.tenantRepo.FindActive(ctx)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get active tenants", errx.TypeInternal)
	}

	var responses []tenant.TenantResponse
	for _, t := range tenants {
		config, _ := s.tenantConfigRepo.FindByTenant(ctx, t.ID)
		if config == nil {
			config = make(map[string]string)
		}
		responses = append(responses, tenant.TenantResponse{
			Tenant: *t,
			Config: config,
		})
	}

	return &tenant.TenantListResponse{
		Tenants: responses,
		Total:   len(responses),
	}, nil
}

// UpdateTenant actualiza un tenant
func (s *TenantService) UpdateTenant(ctx context.Context, tenantID kernel.TenantID, req tenant.UpdateTenantRequest) (*tenant.Tenant, error) {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	// Actualizar campos si se proporcionaron
	if req.CompanyName != nil {
		tenantEntity.CompanyName = *req.CompanyName
	}
	if req.Status != nil {
		switch *req.Status {
		case tenant.TenantStatusActive:
			tenantEntity.Activate()
		case tenant.TenantStatusSuspended:
			tenantEntity.Suspend("Updated by admin")
		}
	}

	tenantEntity.UpdatedAt = time.Now()

	// Guardar cambios
	if err := s.tenantRepo.Save(ctx, *tenantEntity); err != nil {
		return nil, errx.Wrap(err, "failed to update tenant", errx.TypeInternal)
	}

	return tenantEntity, nil
}

// SuspendTenant suspende un tenant
func (s *TenantService) SuspendTenant(ctx context.Context, tenantID kernel.TenantID, reason string) error {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return tenant.ErrTenantNotFound()
	}

	tenantEntity.Suspend(reason)
	return s.tenantRepo.Save(ctx, *tenantEntity)
}

// ActivateTenant activa un tenant
func (s *TenantService) ActivateTenant(ctx context.Context, tenantID kernel.TenantID) error {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return tenant.ErrTenantNotFound()
	}

	tenantEntity.Activate()
	return s.tenantRepo.Save(ctx, *tenantEntity)
}

// UpgradeTenantPlan mejora el plan de suscripción de un tenant
func (s *TenantService) UpgradeTenantPlan(ctx context.Context, tenantID kernel.TenantID, newPlan tenant.SubscriptionPlan) error {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return tenant.ErrTenantNotFound()
	}

	if err := tenantEntity.UpgradePlan(newPlan); err != nil {
		return err
	}

	// Actualizar fecha de expiración de suscripción
	if newPlan != tenant.PlanTrial {
		expirationDate := s.calculateSubscriptionExpiration()
		tenantEntity.SubscriptionExpiresAt = expirationDate
	}

	return s.tenantRepo.Save(ctx, *tenantEntity)
}

// GetTenantUsers obtiene todos los usuarios de un tenant
func (s *TenantService) GetTenantUsers(ctx context.Context, tenantID kernel.TenantID) ([]*user.User, error) {
	// Verificar que el tenant existe
	_, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	users, err := s.userRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get tenant users", errx.TypeInternal)
	}

	return users, nil
}

// SetTenantConfig establece una configuración del tenant
func (s *TenantService) SetTenantConfig(ctx context.Context, tenantID kernel.TenantID, key, value string) error {
	// Verificar que el tenant existe
	_, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return tenant.ErrTenantNotFound()
	}

	return s.tenantConfigRepo.SaveSetting(ctx, tenantID, key, value)
}

// GetTenantConfig obtiene todas las configuraciones del tenant
func (s *TenantService) GetTenantConfig(ctx context.Context, tenantID kernel.TenantID) (*tenant.TenantConfigResponse, error) {
	// Verificar que el tenant existe
	_, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	config, err := s.tenantConfigRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get tenant config", errx.TypeInternal)
	}

	return &tenant.TenantConfigResponse{
		TenantID: tenantID,
		Config:   config,
	}, nil
}

// DeleteTenantConfig elimina una configuración del tenant
func (s *TenantService) DeleteTenantConfig(ctx context.Context, tenantID kernel.TenantID, key string) error {
	// Verificar que el tenant existe
	_, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return tenant.ErrTenantNotFound()
	}

	return s.tenantConfigRepo.DeleteSetting(ctx, tenantID, key)
}

// GetTenantStats obtiene estadísticas del tenant
func (s *TenantService) GetTenantStats(ctx context.Context, tenantID kernel.TenantID) (*tenant.TenantStatsResponse, error) {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	// Contar usuarios activos
	users, err := s.userRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get users for stats", errx.TypeInternal)
	}

	activeUsers := 0
	for _, u := range users {
		if u.IsActive() {
			activeUsers++
		}
	}

	stats := &tenant.TenantStatsResponse{
		TenantID:              tenantEntity.ID,
		TotalUsers:            tenantEntity.CurrentUsers,
		ActiveUsers:           activeUsers,
		MaxUsers:              tenantEntity.MaxUsers,
		UserUtilization:       float64(tenantEntity.CurrentUsers) / float64(tenantEntity.MaxUsers) * 100,
		IsTrialExpired:        tenantEntity.IsTrialExpired(),
		IsSubscriptionExpired: tenantEntity.IsSubscriptionExpired(),
	}

	// Calcular días hasta expiración
	if tenantEntity.SubscriptionExpiresAt != nil && !tenantEntity.IsSubscriptionExpired() {
		days := int(time.Until(*tenantEntity.SubscriptionExpiresAt).Hours() / 24)
		stats.DaysUntilExpiration = &days
	}

	// Determinar estado de suscripción
	if tenantEntity.IsTrialExpired() {
		stats.SubscriptionStatus = "Trial Expired"
	} else if tenantEntity.IsSubscriptionExpired() {
		stats.SubscriptionStatus = "Subscription Expired"
	} else if tenantEntity.IsTrial() {
		stats.SubscriptionStatus = "Trial Active"
	} else {
		stats.SubscriptionStatus = "Subscription Active"
	}

	return stats, nil
}

// GetTenantUsage obtiene información de uso del tenant
func (s *TenantService) GetTenantUsage(ctx context.Context, tenantID kernel.TenantID) (*tenant.TenantUsageResponse, error) {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	usage := &tenant.TenantUsageResponse{
		TenantID:        tenantEntity.ID,
		CurrentUsers:    tenantEntity.CurrentUsers,
		MaxUsers:        tenantEntity.MaxUsers,
		UsagePercentage: float64(tenantEntity.CurrentUsers) / float64(tenantEntity.MaxUsers) * 100,
		CanAddUsers:     tenantEntity.CanAddUser(),
		RemainingUsers:  tenantEntity.MaxUsers - tenantEntity.CurrentUsers,
	}

	return usage, nil
}

// DeleteTenant elimina un tenant (soft delete recomendado)
func (s *TenantService) DeleteTenant(ctx context.Context, tenantID kernel.TenantID) error {
	// Verificar que el tenant existe
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return tenant.ErrTenantNotFound()
	}

	// Verificar que no tenga usuarios activos
	users, err := s.userRepo.FindByTenant(ctx, tenantID)
	if err == nil && len(users) > 0 {
		return tenant.ErrTenantHasUsers()
	}

	// En lugar de eliminar, suspender permanentemente
	tenantEntity.Suspend("Tenant deleted")
	return s.tenantRepo.Save(ctx, *tenantEntity)
}

// BulkSuspendTenants suspende múltiples tenants
func (s *TenantService) BulkSuspendTenants(ctx context.Context, tenantIDs []kernel.TenantID, reason string) (*tenant.BulkTenantOperationResponse, error) {
	result := &tenant.BulkTenantOperationResponse{
		Successful: []kernel.TenantID{},
		Failed:     make(map[kernel.TenantID]string),
		Total:      len(tenantIDs),
	}

	for _, tenantID := range tenantIDs {
		if err := s.SuspendTenant(ctx, tenantID, reason); err != nil {
			result.Failed[tenantID] = err.Error()
		} else {
			result.Successful = append(result.Successful, tenantID)
		}
	}

	return result, nil
}

// BulkActivateTenants activa múltiples tenants
func (s *TenantService) BulkActivateTenants(ctx context.Context, tenantIDs []kernel.TenantID) (*tenant.BulkTenantOperationResponse, error) {
	result := &tenant.BulkTenantOperationResponse{
		Successful: []kernel.TenantID{},
		Failed:     make(map[kernel.TenantID]string),
		Total:      len(tenantIDs),
	}

	for _, tenantID := range tenantIDs {
		if err := s.ActivateTenant(ctx, tenantID); err != nil {
			result.Failed[tenantID] = err.Error()
		} else {
			result.Successful = append(result.Successful, tenantID)
		}
	}

	return result, nil
}

// Helper methods
func (s *TenantService) getMaxUsersForPlan(plan tenant.SubscriptionPlan) int {
	switch plan {
	case tenant.PlanTrial, tenant.PlanBasic:
		return 5
	case tenant.PlanProfessional:
		return 50
	case tenant.PlanEnterprise:
		return 500
	default:
		return 1
	}
}

func (s *TenantService) calculateTrialExpiration() *time.Time {
	expiration := time.Now().AddDate(0, 0, s.config.TrialDays)
	return &expiration
}

func (s *TenantService) calculateSubscriptionExpiration() *time.Time {
	expiration := time.Now().AddDate(s.config.SubscriptionYears, 0, 0)
	return &expiration
}
package tenantinfra

import (
	"context"
	"database/sql"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam/tenant"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/jmoiron/sqlx"
)

// PostgresTenantRepository implementación de PostgreSQL para TenantRepository
type PostgresTenantRepository struct {
	db *sqlx.DB
}

// NewPostgresTenantRepository crea una nueva instancia del repositorio de tenants
func NewPostgresTenantRepository(db *sqlx.DB) tenant.TenantRepository {
	return &PostgresTenantRepository{
		db: db,
	}
}

// FindByID busca un tenant por ID
func (r *PostgresTenantRepository) FindByID(ctx context.Context, id kernel.TenantID) (*tenant.Tenant, error) {
	query := `
		SELECT
			id, company_name, status, subscription_plan,
			max_users, current_users, trial_expires_at, subscription_expires_at,
			created_at, updated_at
		FROM tenants
		WHERE id = $1`

	var t tenant.Tenant
	err := r.db.GetContext(ctx, &t, query, id.String())
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, tenant.ErrTenantNotFound().WithDetail("tenant_id", id.String())
		}
		return nil, errx.Wrap(err, "failed to find tenant by id", errx.TypeInternal).
			WithDetail("tenant_id", id.String())
	}

	return &t, nil
}

// FindAll busca todos los tenants
func (r *PostgresTenantRepository) FindAll(ctx context.Context) ([]*tenant.Tenant, error) {
	query := `
		SELECT
			id, company_name, status, subscription_plan,
			max_users, current_users, trial_expires_at, subscription_expires_at,
			created_at, updated_at
		FROM tenants
		ORDER BY company_name ASC`

	var tenants []tenant.Tenant
	err := r.db.SelectContext(ctx, &tenants, query)
	if err != nil {
		return nil, errx.Wrap(err, "failed to find all tenants", errx.TypeInternal)
	}

	// Convertir a slice de punteros
	result := make([]*tenant.Tenant, len(tenants))
	for i := range tenants {
		result[i] = &tenants[i]
	}

	return result, nil
}

// FindActive busca todos los tenants activos
func (r *PostgresTenantRepository) FindActive(ctx context.Context) ([]*tenant.Tenant, error) {
	query := `
		SELECT
			id, company_name, status, subscription_plan,
			max_users, current_users, trial_expires_at, subscription_expires_at,
			created_at, updated_at
		FROM tenants
		WHERE status = 'ACTIVE'
		ORDER BY company_name ASC`

	var tenants []tenant.Tenant
	err := r.db.SelectContext(ctx, &tenants, query)
	if err != nil {
		return nil, errx.Wrap(err, "failed to find active tenants", errx.TypeInternal)
	}

	// Convertir a slice de punteros
	result := make([]*tenant.Tenant, len(tenants))
	for i := range tenants {
		result[i] = &tenants[i]
	}

	return result, nil
}

// Save guarda o actualiza un tenant
func (r *PostgresTenantRepository) Save(ctx context.Context, t tenant.Tenant) error {
	// Verificar si el tenant ya existe
	exists, err := r.tenantExists(ctx, t.ID)
	if err != nil {
		return errx.Wrap(err, "failed to check tenant existence", errx.TypeInternal)
	}

	if exists {
		return r.update(ctx, t)
	}
	return r.create(ctx, t)
}

// create crea un nuevo tenant
func (r *PostgresTenantRepository) create(ctx context.Context, t tenant.Tenant) error {
	query := `
		INSERT INTO tenants (
			id, company_name, status, subscription_plan,
			max_users, current_users, trial_expires_at, subscription_expires_at,
			created_at, updated_at
		) VALUES (
			:id, :company_name, :status, :subscription_plan,
			:max_users, :current_users, :trial_expires_at, :subscription_expires_at,
			:created_at, :updated_at
		)`

	_, err := r.db.NamedExecContext(ctx, query, t)
	if err != nil {
		return errx.Wrap(err, "failed to create tenant", errx.TypeInternal).
			WithDetail("tenant_id", t.ID.String())
	}

	return nil
}

// update actualiza un tenant existente
func (r *PostgresTenantRepository) update(ctx context.Context, t tenant.Tenant) error {
	query := `
		UPDATE tenants SET
			company_name = :company_name,
			status = :status,
			subscription_plan = :subscription_plan,
			max_users = :max_users,
			current_users = :current_users,
			trial_expires_at = :trial_expires_at,
			subscription_expires_at = :subscription_expires_at,
			updated_at = :updated_at
		WHERE id = :id`

	result, err := r.db.NamedExecContext(ctx, query, t)
	if err != nil {
		return errx.Wrap(err, "failed to update tenant", errx.TypeInternal).
			WithDetail("tenant_id", t.ID.String())
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return tenant.ErrTenantNotFound().WithDetail("tenant_id", t.ID.String())
	}

	return nil
}

// Delete elimina un tenant
func (r *PostgresTenantRepository) Delete(ctx context.Context, id kernel.TenantID) error {
	query := `DELETE FROM tenants WHERE id = $1`

	result, err := r.db.ExecContext(ctx, query, id.String())
	if err != nil {
		return errx.Wrap(err, "failed to delete tenant", errx.TypeInternal).
			WithDetail("tenant_id", id.String())
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return tenant.ErrTenantNotFound().WithDetail("tenant_id", id.String())
	}

	return nil
}

// tenantExists verifica si un tenant existe por ID
func (r *PostgresTenantRepository) tenantExists(ctx context.Context, id kernel.TenantID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM tenants WHERE id = $1)`

	var exists bool
	err := r.db.GetContext(ctx, &exists, query, id.String())
	if err != nil {
		return false, errx.Wrap(err, "failed to check tenant existence", errx.TypeInternal).
			WithDetail("tenant_id", id.String())
	}

	return exists, nil
}

// ============================================================================
// TenantConfigRepository Implementation
// ============================================================================

// PostgresTenantConfigRepository implementación de PostgreSQL para TenantConfigRepository
type PostgresTenantConfigRepository struct {
	db *sqlx.DB
}

// NewPostgresTenantConfigRepository crea una nueva instancia del repositorio de configuración de tenants
func NewPostgresTenantConfigRepository(db *sqlx.DB) tenant.TenantConfigRepository {
	return &PostgresTenantConfigRepository{
		db: db,
	}
}

// FindByTenant busca toda la configuración de un tenant
func (r *PostgresTenantConfigRepository) FindByTenant(ctx context.Context, tenantID kernel.TenantID) (map[string]string, error) {
	query := `
		SELECT key, value 
		FROM tenant_config 
		WHERE tenant_id = $1`

	rows, err := r.db.QueryContext(ctx, query, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find tenant config", errx.TypeInternal).
			WithDetail("tenant_id", tenantID.String())
	}
	defer rows.Close()

	config := make(map[string]string)
	for rows.Next() {
		var key, value string
		if err := rows.Scan(&key, &value); err != nil {
			return nil, errx.Wrap(err, "failed to scan tenant config", errx.TypeInternal)
		}
		config[key] = value
	}

	if err := rows.Err(); err != nil {
		return nil, errx.Wrap(err, "error iterating tenant config rows", errx.TypeInternal)
	}

	return config, nil
}

// SaveSetting guarda una configuración específica de un tenant
func (r *PostgresTenantConfigRepository) SaveSetting(ctx context.Context, tenantID kernel.TenantID, key, value string) error {
	query := `
		INSERT INTO tenant_config (tenant_id, key, value, created_at, updated_at)
		VALUES ($1, $2, $3, NOW(), NOW())
		ON CONFLICT (tenant_id, key) DO UPDATE
		SET value = EXCLUDED.value, updated_at = NOW()`

	_, err := r.db.ExecContext(ctx, query, tenantID.String(), key, value)
	if err != nil {
		return errx.Wrap(err, "failed to save tenant config setting", errx.TypeInternal).
			WithDetail("tenant_id", tenantID.String()).
			WithDetail("key", key)
	}

	return nil
}

// DeleteSetting elimina una configuración específica de un tenant
func (r *PostgresTenantConfigRepository) DeleteSetting(ctx context.Context, tenantID kernel.TenantID, key string) error {
	query := `DELETE FROM tenant_config WHERE tenant_id = $1 AND key = $2`

	result, err := r.db.ExecContext(ctx, query, tenantID.String(), key)
	if err != nil {
		return errx.Wrap(err, "failed to delete tenant config setting", errx.TypeInternal).
			WithDetail("tenant_id", tenantID.String()).
			WithDetail("key", key)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return errx.New("tenant config setting not found", errx.TypeNotFound).
			WithDetail("tenant_id", tenantID.String()).
			WithDetail("key", key)
	}

	return nil
}
package iam

import (
	"net/http"

	"github.com/Abraxas-365/manifesto/pkg/errx"
)

// ============================================================================
// Error Registry - Registro de errores del módulo IAM
// ============================================================================

var ErrRegistry = errx.NewRegistry("IAM")

// Códigos de error del módulo IAM
var (
	// Errores comunes
	CodeUnauthorized = ErrRegistry.Register("UNAUTHORIZED", errx.TypeAuthorization, http.StatusUnauthorized, "No autorizado")
	CodeInvalidToken = ErrRegistry.Register("INVALID_TOKEN", errx.TypeAuthorization, http.StatusUnauthorized, "Token inválido o expirado")
	CodeAccessDenied = ErrRegistry.Register("ACCESS_DENIED", errx.TypeAuthorization, http.StatusForbidden, "Acceso denegado")
)

// Helper functions para crear errores comunes
func ErrUnauthorized() *errx.Error {
	return ErrRegistry.New(CodeUnauthorized)
}

func ErrInvalidToken() *errx.Error {
	return ErrRegistry.New(CodeInvalidToken)
}

func ErrAccessDenied() *errx.Error {
	return ErrRegistry.New(CodeAccessDenied)
}

// OAuthProvider representa los proveedores OAuth soportados
type OAuthProvider string

const (
	OAuthProviderGoogle    OAuthProvider = "GOOGLE"
	OAuthProviderMicrosoft OAuthProvider = "MICROSOFT"
	OAuthProviderAuth0     OAuthProvider = "AUTH0"
)

// GetProviderName retorna el nombre legible del proveedor
func (p OAuthProvider) GetProviderName() string {
	switch p {
	case OAuthProviderGoogle:
		return "Google"
	case OAuthProviderMicrosoft:
		return "Microsoft"
	case OAuthProviderAuth0:
		return "Auth0"
	default:
		return "Unknown"
	}
}
// pkg/auth/config.go
package auth

import (
	"net/http"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/errx"
)

// Config configuración completa del módulo de autenticación
type Config struct {
	JWT   JWTConfig    `json:"jwt" yaml:"jwt"`
	OAuth OAuthConfigs `json:"oauth" yaml:"oauth"`
}

// JWTConfig configuración para JWT
type JWTConfig struct {
	SecretKey       string        `json:"secret_key" yaml:"secret_key"`
	AccessTokenTTL  time.Duration `json:"access_token_ttl" yaml:"access_token_ttl"`
	RefreshTokenTTL time.Duration `json:"refresh_token_ttl" yaml:"refresh_token_ttl"`
	Issuer          string        `json:"issuer" yaml:"issuer"`
}

// OAuthConfig configuración base para OAuth
type OAuthConfig struct {
	ClientID     string   `json:"client_id"`
	ClientSecret string   `json:"client_secret"`
	RedirectURL  string   `json:"redirect_url"`
	Scopes       []string `json:"scopes"`
}

// OAuthConfigs configuraciones para todos los proveedores OAuth
type OAuthConfigs struct {
	Google    OAuthConfig `json:"google" yaml:"google"`
	Microsoft OAuthConfig `json:"microsoft" yaml:"microsoft"`
}

// DefaultConfig retorna configuración por defecto
func DefaultConfig() Config {
	return Config{
		JWT: JWTConfig{
			AccessTokenTTL:  15 * time.Minute,
			RefreshTokenTTL: 7 * 24 * time.Hour,
			Issuer:          "facturamelo",
		},
		OAuth: OAuthConfigs{
			Google: OAuthConfig{
				Scopes: []string{"openid", "email", "profile"},
			},
			Microsoft: OAuthConfig{
				Scopes: []string{"openid", "email", "profile", "User.Read"},
			},
		},
	}
}

// Validate valida la configuración
func (c *Config) Validate() error {
	if c.JWT.SecretKey == "" {
		return ErrMissingJWTSecret()
	}

	if len(c.JWT.SecretKey) < 32 {
		return ErrWeakJWTSecret()
	}

	if c.JWT.AccessTokenTTL <= 0 {
		return ErrInvalidTokenTTL().WithDetail("token_type", "access")
	}

	if c.JWT.RefreshTokenTTL <= 0 {
		return ErrInvalidTokenTTL().WithDetail("token_type", "refresh")
	}

	// Validar configuración OAuth si está presente
	if err := c.OAuth.Google.Validate("Google"); err != nil {
		return err
	}

	if err := c.OAuth.Microsoft.Validate("Microsoft"); err != nil {
		return err
	}

	return nil
}

// Validate valida la configuración OAuth
func (oc *OAuthConfig) Validate(provider string) error {
	// Solo validar si hay configuración (permite proveedores opcionales)
	if oc.ClientID == "" && oc.ClientSecret == "" {
		return nil // Proveedor no configurado, está bien
	}

	if oc.ClientID == "" {
		return ErrMissingOAuthClientID().WithDetail("provider", provider)
	}

	if oc.ClientSecret == "" {
		return ErrMissingOAuthClientSecret().WithDetail("provider", provider)
	}

	if oc.RedirectURL == "" {
		return ErrMissingOAuthRedirectURL().WithDetail("provider", provider)
	}

	if len(oc.Scopes) == 0 {
		return ErrMissingOAuthScopes().WithDetail("provider", provider)
	}

	return nil
}

// IsEnabled verifica si el proveedor OAuth está habilitado
func (oc *OAuthConfig) IsEnabled() bool {
	return oc.ClientID != "" && oc.ClientSecret != ""
}

// GetEnabledProviders retorna una lista de proveedores OAuth habilitados
func (oc *OAuthConfigs) GetEnabledProviders() []string {
	var enabled []string

	if oc.Google.IsEnabled() {
		enabled = append(enabled, "google")
	}

	if oc.Microsoft.IsEnabled() {
		enabled = append(enabled, "microsoft")
	}

	return enabled
}

// Config error codes
var (
	CodeMissingJWTSecret         = ErrRegistry.Register("MISSING_JWT_SECRET", errx.TypeValidation, http.StatusBadRequest, "JWT secret key is required")
	CodeWeakJWTSecret            = ErrRegistry.Register("WEAK_JWT_SECRET", errx.TypeValidation, http.StatusBadRequest, "JWT secret key must be at least 32 characters")
	CodeInvalidTokenTTL          = ErrRegistry.Register("INVALID_TOKEN_TTL", errx.TypeValidation, http.StatusBadRequest, "Invalid token TTL")
	CodeMissingOAuthClientID     = ErrRegistry.Register("MISSING_OAUTH_CLIENT_ID", errx.TypeValidation, http.StatusBadRequest, "OAuth client ID is required")
	CodeMissingOAuthClientSecret = ErrRegistry.Register("MISSING_OAUTH_CLIENT_SECRET", errx.TypeValidation, http.StatusBadRequest, "OAuth client secret is required")
	CodeMissingOAuthRedirectURL  = ErrRegistry.Register("MISSING_OAUTH_REDIRECT_URL", errx.TypeValidation, http.StatusBadRequest, "OAuth redirect URL is required")
	CodeMissingOAuthScopes       = ErrRegistry.Register("MISSING_OAUTH_SCOPES", errx.TypeValidation, http.StatusBadRequest, "OAuth scopes are required")
)

// Helper functions para crear errores de configuración
func ErrMissingJWTSecret() *errx.Error {
	return ErrRegistry.New(CodeMissingJWTSecret)
}

func ErrWeakJWTSecret() *errx.Error {
	return ErrRegistry.New(CodeWeakJWTSecret)
}

func ErrInvalidTokenTTL() *errx.Error {
	return ErrRegistry.New(CodeInvalidTokenTTL)
}

func ErrMissingOAuthClientID() *errx.Error {
	return ErrRegistry.New(CodeMissingOAuthClientID)
}

func ErrMissingOAuthClientSecret() *errx.Error {
	return ErrRegistry.New(CodeMissingOAuthClientSecret)
}

func ErrMissingOAuthRedirectURL() *errx.Error {
	return ErrRegistry.New(CodeMissingOAuthRedirectURL)
}

func ErrMissingOAuthScopes() *errx.Error {
	return ErrRegistry.New(CodeMissingOAuthScopes)
}
package auth

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"sync"
	"time"
)

// InMemoryStateManager implementación en memoria del StateManager
type InMemoryStateManager struct {
	states map[string]*stateEntry
	mu     sync.RWMutex
	ttl    time.Duration // Add this field
}

type stateEntry struct {
	data      map[string]any
	expiresAt time.Time
}

// NewInMemoryStateManager crea un nuevo state manager en memoria
func NewInMemoryStateManager(ttl time.Duration) *InMemoryStateManager {
	return &InMemoryStateManager{
		states: make(map[string]*stateEntry),
		ttl:    ttl,
	}
}

// GenerateState genera un nuevo estado OAuth
func (sm *InMemoryStateManager) GenerateState() string {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		// Fallback en caso de error
		return fmt.Sprintf("%d", time.Now().UnixNano())
	}
	return hex.EncodeToString(bytes)
}

// StoreState almacena un estado con sus datos asociados
func (sm *InMemoryStateManager) StoreState(ctx context.Context, state string, data map[string]any) error {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	sm.states[state] = &stateEntry{
		data:      data,
		expiresAt: time.Now().Add(sm.ttl), // Estados válidos por 10 minutos
	}

	return nil
}

// ValidateState valida si un estado es válido
func (sm *InMemoryStateManager) ValidateState(state string) bool {
	sm.mu.RLock()
	defer sm.mu.RUnlock()

	entry, exists := sm.states[state]
	if !exists {
		return false
	}

	return time.Now().Before(entry.expiresAt)
}

// GetStateData obtiene los datos asociados a un estado
func (sm *InMemoryStateManager) GetStateData(ctx context.Context, state string) (map[string]any, error) {
	sm.mu.Lock()
	defer sm.mu.Unlock()

	entry, exists := sm.states[state]
	if !exists {
		return nil, ErrInvalidState()
	}

	if time.Now().After(entry.expiresAt) {
		delete(sm.states, state)
		return nil, ErrInvalidState()
	}

	// Eliminar el estado después de usarlo (one-time use)
	data := entry.data
	delete(sm.states, state)

	return data, nil
}

// cleanup limpia estados expirados periodicamente
func (sm *InMemoryStateManager) cleanup() {
	ticker := time.NewTicker(5 * time.Minute)
	defer ticker.Stop()

	for range ticker.C {
		sm.mu.Lock()
		now := time.Now()
		for state, entry := range sm.states {
			if now.After(entry.expiresAt) {
				delete(sm.states, state)
			}
		}
		sm.mu.Unlock()
	}
}
package auth

import (
	"strings"

	"github.com/Abraxas-365/manifesto/pkg/iam"
	"github.com/Abraxas-365/manifesto/pkg/iam/apikey"
	"github.com/Abraxas-365/manifesto/pkg/iam/apikey/apikeysrv"
	"github.com/Abraxas-365/manifesto/pkg/iam/scopes"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/gofiber/fiber/v2"
)

type UnifiedAuthMiddleware struct {
	apiKeyService *apikeysrv.APIKeyService
	tokenService  TokenService
}

func NewAPIKeyMiddleware(
	apiKeyService *apikeysrv.APIKeyService,
	tokenService TokenService,
) *UnifiedAuthMiddleware {
	return &UnifiedAuthMiddleware{
		apiKeyService: apiKeyService,
		tokenService:  tokenService,
	}
}

func (am *UnifiedAuthMiddleware) Authenticate() fiber.Handler {
	return func(c *fiber.Ctx) error {
		apiKey := extractAPIKey(c)
		if apiKey != "" {
			return am.authenticateAPIKey(c, apiKey)
		}

		return am.authenticateJWT(c)
	}
}

func (am *UnifiedAuthMiddleware) authenticateAPIKey(c *fiber.Ctx, keyString string) error {
	key, err := am.apiKeyService.ValidateAPIKey(c.Context(), keyString)
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	authContext := &kernel.AuthContext{
		UserID:   key.UserID,
		TenantID: key.TenantID,
		Scopes:   key.Scopes,
		IsAPIKey: true,
	}

	c.Locals("auth", authContext)
	c.Locals("api_key_id", key.ID)

	return c.Next()
}

func (am *UnifiedAuthMiddleware) authenticateJWT(c *fiber.Ctx) error {
	authHeader := c.Get("Authorization")
	var token string

	if authHeader != "" {
		parts := strings.SplitN(authHeader, " ", 2)
		if len(parts) == 2 && parts[0] == "Bearer" && parts[1] != "" {
			token = parts[1]
		}
	}

	if token == "" {
		token = c.Cookies("access_token")
	}

	if token == "" {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": iam.ErrUnauthorized().Error(),
		})
	}

	claims, err := am.tokenService.ValidateAccessToken(token)
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	authContext := &kernel.AuthContext{
		UserID:   &claims.UserID,
		TenantID: claims.TenantID,
		Email:    claims.Email,
		Name:     claims.Name,
		Scopes:   claims.Scopes,
		IsAPIKey: false,
	}

	c.Locals("auth", authContext)
	return c.Next()
}

// RequireScope - Requires a specific scope (works for both JWT and API keys)
func (am *UnifiedAuthMiddleware) RequireScope(scope string) fiber.Handler {
	return func(c *fiber.Ctx) error {
		authContext, ok := GetAuthContext(c)
		if !ok {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": "Authentication required",
			})
		}

		if !authContext.HasScope(scope) {
			return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
				"error":          "Insufficient permissions",
				"required_scope": scope,
			})
		}

		return c.Next()
	}
}

// RequireAdmin - Only admin users (users/API keys with "*" or "admin:*" scope)
func (am *UnifiedAuthMiddleware) RequireAdmin() fiber.Handler {
	return am.RequireAnyScope(scopes.ScopeAll, scopes.ScopeAdminAll)
}

// RequireAdminOrScope - Admin OR specific scope
func (am *UnifiedAuthMiddleware) RequireAdminOrScope(scope string) fiber.Handler {
	return am.RequireAnyScope(scopes.ScopeAll, scopes.ScopeAdminAll, scope)
}

// RequireAnyScope - Requires any of the provided scopes (works for both JWT and API keys)
func (am *UnifiedAuthMiddleware) RequireAnyScope(scopes ...string) fiber.Handler {
	return func(c *fiber.Ctx) error {
		authContext, ok := GetAuthContext(c)
		if !ok {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": "Authentication required",
			})
		}

		if !authContext.HasAnyScope(scopes...) {
			return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
				"error":           "Insufficient permissions",
				"required_scopes": scopes,
			})
		}

		return c.Next()
	}
}

// RequireAllScopes - Requires ALL specified scopes (AND logic, works for both JWT and API keys)
func (am *UnifiedAuthMiddleware) RequireAllScopes(scopes ...string) fiber.Handler {
	return func(c *fiber.Ctx) error {
		authContext, ok := GetAuthContext(c)
		if !ok {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": "Authentication required",
			})
		}

		if !authContext.HasAllScopes(scopes...) {
			return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
				"error":           "Insufficient permissions",
				"required_scopes": scopes,
			})
		}

		return c.Next()
	}
}

// Helper functions
func extractAPIKey(c *fiber.Ctx) string {
	authHeader := c.Get("Authorization")
	if authHeader != "" {
		parts := strings.SplitN(authHeader, " ", 2)
		if len(parts) == 2 && (parts[0] == "Bearer" || parts[0] == "X-API-Key") {
			if apikey.ValidateAPIKeyFormat(parts[1]) {
				return parts[1]
			}
		}
	}

	apiKeyHeader := c.Get("X-API-Key")
	if apiKeyHeader != "" && apikey.ValidateAPIKeyFormat(apiKeyHeader) {
		return apiKeyHeader
	}

	apiKeyQuery := c.Query("api_key")
	if apiKeyQuery != "" && apikey.ValidateAPIKeyFormat(apiKeyQuery) {
		return apiKeyQuery
	}

	return ""
}

// GetAuthContext helper to extract auth context from Fiber
func GetAuthContext(c *fiber.Ctx) (*kernel.AuthContext, bool) {
	authContext, ok := c.Locals("auth").(*kernel.AuthContext)
	return authContext, ok && authContext != nil && authContext.IsValid()
}
package authinfra

import (
	"github.com/Abraxas-365/manifesto/pkg/iam/user"
	"golang.org/x/crypto/bcrypt"
)

// BcryptPasswordService implementación del servicio de contraseñas usando bcrypt
type BcryptPasswordService struct {
	cost int
}

// NewBcryptPasswordService crea una nueva instancia del servicio de contraseñas
func NewBcryptPasswordService(cost int) user.PasswordService {
	if cost == 0 {
		cost = bcrypt.DefaultCost
	}
	return &BcryptPasswordService{
		cost: cost,
	}
}

// HashPassword hashea una contraseña
func (s *BcryptPasswordService) HashPassword(password string) (string, error) {
	hashedBytes, err := bcrypt.GenerateFromPassword([]byte(password), s.cost)
	if err != nil {
		return "", err
	}
	return string(hashedBytes), nil
}

// VerifyPassword verifica una contraseña contra su hash
func (s *BcryptPasswordService) VerifyPassword(hashedPassword, password string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
	return err == nil
}
package authinfra

import (
	"context"
	"log"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/iam/auth"
)

// CleanupService servicio de limpieza en background
type CleanupService struct {
	tokenRepo         auth.TokenRepository
	sessionRepo       auth.SessionRepository
	passwordResetRepo auth.PasswordResetRepository
	interval          time.Duration
}

// NewCleanupService crea un nuevo servicio de limpieza
func NewCleanupService(
	tokenRepo auth.TokenRepository,
	sessionRepo auth.SessionRepository,
	passwordResetRepo auth.PasswordResetRepository,
	interval time.Duration,
) *CleanupService {
	return &CleanupService{
		tokenRepo:         tokenRepo,
		sessionRepo:       sessionRepo,
		passwordResetRepo: passwordResetRepo,
		interval:          interval,
	}
}

// Start inicia el servicio de limpieza
func (s *CleanupService) Start(ctx context.Context) {
	ticker := time.NewTicker(s.interval)
	defer ticker.Stop()

	// Ejecutar limpieza inicial
	s.runCleanup(ctx)

	for {
		select {
		case <-ctx.Done():
			log.Println("Cleanup service stopped")
			return
		case <-ticker.C:
			s.runCleanup(ctx)
		}
	}
}

// runCleanup ejecuta las tareas de limpieza
func (s *CleanupService) runCleanup(ctx context.Context) {
	log.Println("Running cleanup tasks...")

	// Limpiar refresh tokens expirados
	if err := s.tokenRepo.CleanExpiredTokens(ctx); err != nil {
		log.Printf("Error cleaning expired tokens: %v", err)
	}

	// Limpiar sesiones expiradas
	if err := s.sessionRepo.CleanExpiredSessions(ctx); err != nil {
		log.Printf("Error cleaning expired sessions: %v", err)
	}

	// Limpiar tokens de reset expirados
	if err := s.passwordResetRepo.CleanExpiredResetTokens(ctx); err != nil {
		log.Printf("Error cleaning expired reset tokens: %v", err)
	}

	log.Println("Cleanup tasks completed")
}
package authinfra

import (
	"context"
	"database/sql"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam/auth"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/jmoiron/sqlx"
)

// PostgresSessionRepository implementación de PostgreSQL para SessionRepository
type PostgresSessionRepository struct {
	db *sqlx.DB
}

// NewPostgresSessionRepository crea una nueva instancia del repositorio de sesiones
func NewPostgresSessionRepository(db *sqlx.DB) auth.SessionRepository {
	return &PostgresSessionRepository{
		db: db,
	}
}

// SaveSession guarda una nueva sesión de usuario
func (r *PostgresSessionRepository) SaveSession(ctx context.Context, session auth.UserSession) error {
	query := `
		INSERT INTO user_sessions (
			id, user_id, tenant_id, session_token, ip_address, 
			user_agent, expires_at, created_at, last_activity
		) VALUES (
			:id, :user_id, :tenant_id, :session_token, :ip_address,
			:user_agent, :expires_at, :created_at, :last_activity
		)`

	_, err := r.db.NamedExecContext(ctx, query, session)
	if err != nil {
		return errx.Wrap(err, "failed to save session", errx.TypeInternal).
			WithDetail("user_id", session.UserID.String())
	}

	return nil
}

// FindSession busca una sesión por ID
func (r *PostgresSessionRepository) FindSession(ctx context.Context, sessionID string) (*auth.UserSession, error) {
	query := `
		SELECT 
			id, user_id, tenant_id, session_token, ip_address,
			user_agent, expires_at, created_at, last_activity
		FROM user_sessions 
		WHERE id = $1`

	var session auth.UserSession
	err := r.db.GetContext(ctx, &session, query, sessionID)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, errx.New("session not found", errx.TypeNotFound).
				WithDetail("session_id", sessionID)
		}
		return nil, errx.Wrap(err, "failed to find session", errx.TypeInternal).
			WithDetail("session_id", sessionID)
	}

	return &session, nil
}

// FindSessionByToken busca una sesión por token
func (r *PostgresSessionRepository) FindSessionByToken(ctx context.Context, sessionToken string) (*auth.UserSession, error) {
	query := `
		SELECT 
			id, user_id, tenant_id, session_token, ip_address,
			user_agent, expires_at, created_at, last_activity
		FROM user_sessions 
		WHERE session_token = $1 AND expires_at > NOW()`

	var session auth.UserSession
	err := r.db.GetContext(ctx, &session, query, sessionToken)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, errx.New("session not found", errx.TypeNotFound)
		}
		return nil, errx.Wrap(err, "failed to find session by token", errx.TypeInternal)
	}

	return &session, nil
}

// FindUserSessions busca todas las sesiones activas de un usuario
func (r *PostgresSessionRepository) FindUserSessions(ctx context.Context, userID kernel.UserID) ([]*auth.UserSession, error) {
	query := `
		SELECT 
			id, user_id, tenant_id, session_token, ip_address,
			user_agent, expires_at, created_at, last_activity
		FROM user_sessions 
		WHERE user_id = $1 AND expires_at > NOW()
		ORDER BY last_activity DESC`

	var sessions []auth.UserSession
	err := r.db.SelectContext(ctx, &sessions, query, userID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find user sessions", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	// Convertir a slice de punteros
	result := make([]*auth.UserSession, len(sessions))
	for i := range sessions {
		result[i] = &sessions[i]
	}

	return result, nil
}

// UpdateSessionActivity actualiza la última actividad de una sesión
func (r *PostgresSessionRepository) UpdateSessionActivity(ctx context.Context, sessionID string) error {
	query := `
		UPDATE user_sessions 
		SET last_activity = NOW() 
		WHERE id = $1 AND expires_at > NOW()`

	result, err := r.db.ExecContext(ctx, query, sessionID)
	if err != nil {
		return errx.Wrap(err, "failed to update session activity", errx.TypeInternal).
			WithDetail("session_id", sessionID)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return errx.New("session not found or expired", errx.TypeNotFound).
			WithDetail("session_id", sessionID)
	}

	return nil
}

// RevokeSession revoca una sesión específica
func (r *PostgresSessionRepository) RevokeSession(ctx context.Context, sessionID string) error {
	query := `DELETE FROM user_sessions WHERE id = $1`

	result, err := r.db.ExecContext(ctx, query, sessionID)
	if err != nil {
		return errx.Wrap(err, "failed to revoke session", errx.TypeInternal).
			WithDetail("session_id", sessionID)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return errx.New("session not found", errx.TypeNotFound).
			WithDetail("session_id", sessionID)
	}

	return nil
}

// RevokeAllUserSessions revoca todas las sesiones de un usuario
func (r *PostgresSessionRepository) RevokeAllUserSessions(ctx context.Context, userID kernel.UserID) error {
	query := `DELETE FROM user_sessions WHERE user_id = $1`

	_, err := r.db.ExecContext(ctx, query, userID.String())
	if err != nil {
		return errx.Wrap(err, "failed to revoke all user sessions", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	return nil
}

// CleanExpiredSessions elimina sesiones expiradas (para mantenimiento)
func (r *PostgresSessionRepository) CleanExpiredSessions(ctx context.Context) error {
	query := `DELETE FROM user_sessions WHERE expires_at < NOW()`

	_, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return errx.Wrap(err, "failed to clean expired sessions", errx.TypeInternal)
	}

	return nil
}

// ExtendSession extiende la expiración de una sesión
func (r *PostgresSessionRepository) ExtendSession(ctx context.Context, sessionID string, duration time.Duration) error {
	query := `
		UPDATE user_sessions 
		SET expires_at = expires_at + $2::interval,
		    last_activity = NOW()
		WHERE id = $1 AND expires_at > NOW()`

	result, err := r.db.ExecContext(ctx, query, sessionID, duration)
	if err != nil {
		return errx.Wrap(err, "failed to extend session", errx.TypeInternal).
			WithDetail("session_id", sessionID).
			WithDetail("duration", duration.String())
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return errx.New("session not found or expired", errx.TypeNotFound).
			WithDetail("session_id", sessionID)
	}

	return nil
}

// CountActiveSessions cuenta las sesiones activas de un usuario
func (r *PostgresSessionRepository) CountActiveSessions(ctx context.Context, userID kernel.UserID) (int, error) {
	query := `
		SELECT COUNT(*) 
		FROM user_sessions 
		WHERE user_id = $1 AND expires_at > NOW()`

	var count int
	err := r.db.GetContext(ctx, &count, query, userID.String())
	if err != nil {
		return 0, errx.Wrap(err, "failed to count active sessions", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	return count, nil
}

// GetSessionsByIPAddress obtiene sesiones por dirección IP (para seguridad)
func (r *PostgresSessionRepository) GetSessionsByIPAddress(ctx context.Context, ipAddress string) ([]*auth.UserSession, error) {
	query := `
		SELECT 
			id, user_id, tenant_id, session_token, ip_address,
			user_agent, expires_at, created_at, last_activity
		FROM user_sessions 
		WHERE ip_address = $1 AND expires_at > NOW()
		ORDER BY created_at DESC`

	var sessions []auth.UserSession
	err := r.db.SelectContext(ctx, &sessions, query, ipAddress)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get sessions by IP", errx.TypeInternal).
			WithDetail("ip_address", ipAddress)
	}

	// Convertir a slice de punteros
	result := make([]*auth.UserSession, len(sessions))
	for i := range sessions {
		result[i] = &sessions[i]
	}

	return result, nil
}
package authinfra

import (
	"context"
	"database/sql"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam/auth"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/jmoiron/sqlx"
)

// PostgresTokenRepository implementación de PostgreSQL para TokenRepository
type PostgresTokenRepository struct {
	db *sqlx.DB
}

// NewPostgresTokenRepository crea una nueva instancia del repositorio de tokens
func NewPostgresTokenRepository(db *sqlx.DB) auth.TokenRepository {
	return &PostgresTokenRepository{
		db: db,
	}
}

// SaveRefreshToken guarda un nuevo refresh token
func (r *PostgresTokenRepository) SaveRefreshToken(ctx context.Context, token auth.RefreshToken) error {
	query := `
		INSERT INTO refresh_tokens (
			id, token, user_id, tenant_id, expires_at, created_at, is_revoked
		) VALUES (
			:id, :token, :user_id, :tenant_id, :expires_at, :created_at, :is_revoked
		)`

	_, err := r.db.NamedExecContext(ctx, query, token)
	if err != nil {
		return errx.Wrap(err, "failed to save refresh token", errx.TypeInternal).
			WithDetail("user_id", token.UserID.String())
	}

	return nil
}

// FindRefreshToken busca un refresh token por su valor
func (r *PostgresTokenRepository) FindRefreshToken(ctx context.Context, tokenValue string) (*auth.RefreshToken, error) {
	query := `
		SELECT 
			id, token, user_id, tenant_id, expires_at, created_at, is_revoked
		FROM refresh_tokens 
		WHERE token = $1 AND is_revoked = false`

	var token auth.RefreshToken
	err := r.db.GetContext(ctx, &token, query, tokenValue)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, auth.ErrInvalidRefreshToken()
		}
		return nil, errx.Wrap(err, "failed to find refresh token", errx.TypeInternal)
	}

	return &token, nil
}

// RevokeRefreshToken revoca un refresh token
func (r *PostgresTokenRepository) RevokeRefreshToken(ctx context.Context, tokenValue string) error {
	query := `
		UPDATE refresh_tokens 
		SET is_revoked = true 
		WHERE token = $1`

	result, err := r.db.ExecContext(ctx, query, tokenValue)
	if err != nil {
		return errx.Wrap(err, "failed to revoke refresh token", errx.TypeInternal)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return auth.ErrInvalidRefreshToken()
	}

	return nil
}

// RevokeAllUserTokens revoca todos los tokens de un usuario
func (r *PostgresTokenRepository) RevokeAllUserTokens(ctx context.Context, userID kernel.UserID) error {
	query := `
		UPDATE refresh_tokens 
		SET is_revoked = true 
		WHERE user_id = $1 AND is_revoked = false`

	_, err := r.db.ExecContext(ctx, query, userID.String())
	if err != nil {
		return errx.Wrap(err, "failed to revoke all user tokens", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	return nil
}

// CleanExpiredTokens elimina tokens expirados (para mantenimiento)
func (r *PostgresTokenRepository) CleanExpiredTokens(ctx context.Context) error {
	query := `
		DELETE FROM refresh_tokens 
		WHERE expires_at < NOW() OR is_revoked = true`

	_, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return errx.Wrap(err, "failed to clean expired tokens", errx.TypeInternal)
	}

	return nil
}

// CountActiveTokens cuenta tokens activos de un usuario (método adicional útil)
func (r *PostgresTokenRepository) CountActiveTokens(ctx context.Context, userID kernel.UserID) (int, error) {
	query := `
		SELECT COUNT(*) 
		FROM refresh_tokens 
		WHERE user_id = $1 AND is_revoked = false AND expires_at > NOW()`

	var count int
	err := r.db.GetContext(ctx, &count, query, userID.String())
	if err != nil {
		return 0, errx.Wrap(err, "failed to count active tokens", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	return count, nil
}

// GetActiveTokensByUser obtiene todos los tokens activos de un usuario
func (r *PostgresTokenRepository) GetActiveTokensByUser(ctx context.Context, userID kernel.UserID) ([]*auth.RefreshToken, error) {
	query := `
		SELECT 
			id, token, user_id, tenant_id, expires_at, created_at, is_revoked
		FROM refresh_tokens 
		WHERE user_id = $1 AND is_revoked = false AND expires_at > NOW()
		ORDER BY created_at DESC`

	var tokens []auth.RefreshToken
	err := r.db.SelectContext(ctx, &tokens, query, userID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to get active tokens", errx.TypeInternal).
			WithDetail("user_id", userID.String())
	}

	// Convertir a slice de punteros
	result := make([]*auth.RefreshToken, len(tokens))
	for i := range tokens {
		result[i] = &tokens[i]
	}

	return result, nil
}
package authinfra

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/iam/auth"
	"github.com/google/uuid"
	"github.com/redis/go-redis/v9"
)

// RedisStateManager implementación en Redis del StateManager
type RedisStateManager struct {
	client *redis.Client
	ttl    time.Duration
}

// NewRedisStateManager crea un nuevo state manager con Redis
func NewRedisStateManager(client *redis.Client, ttl time.Duration) auth.StateManager {
	return &RedisStateManager{
		client: client,
		ttl:    ttl,
	}
}

// GenerateState genera un nuevo estado OAuth
func (sm *RedisStateManager) GenerateState() string {
	return uuid.NewString()
}

// StoreState almacena un estado con sus datos asociados
func (sm *RedisStateManager) StoreState(ctx context.Context, state string, data map[string]any) error {
	jsonData, err := json.Marshal(data)
	if err != nil {
		return fmt.Errorf("failed to marshal state data: %w", err)
	}

	key := fmt.Sprintf("oauth_state:%s", state)
	err = sm.client.Set(ctx, key, jsonData, sm.ttl).Err()
	if err != nil {
		return fmt.Errorf("failed to store state in Redis: %w", err)
	}

	return nil
}

// ValidateState valida si un estado es válido
func (sm *RedisStateManager) ValidateState(state string) bool {
	ctx := context.Background()
	key := fmt.Sprintf("oauth_state:%s", state)

	exists, err := sm.client.Exists(ctx, key).Result()
	if err != nil {
		return false
	}

	return exists == 1
}

// GetStateData obtiene los datos asociados a un estado
func (sm *RedisStateManager) GetStateData(ctx context.Context, state string) (map[string]any, error) {
	key := fmt.Sprintf("oauth_state:%s", state)

	// Obtener y eliminar el estado (one-time use)
	jsonData, err := sm.client.GetDel(ctx, key).Result()
	if err != nil {
		if err == redis.Nil {
			return nil, auth.ErrInvalidState()
		}
		return nil, fmt.Errorf("failed to get state from Redis: %w", err)
	}

	var data map[string]any
	if err := json.Unmarshal([]byte(jsonData), &data); err != nil {
		return nil, fmt.Errorf("failed to unmarshal state data: %w", err)
	}

	return data, nil
}
package authinfra

import (
	"context"
	"database/sql"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam/auth"
	"github.com/jmoiron/sqlx"
)

// PostgresPasswordResetRepository implementación de PostgreSQL para PasswordResetRepository
type PostgresPasswordResetRepository struct {
	db *sqlx.DB
}

// NewPostgresPasswordResetRepository crea una nueva instancia del repositorio de reset de contraseña
func NewPostgresPasswordResetRepository(db *sqlx.DB) auth.PasswordResetRepository {
	return &PostgresPasswordResetRepository{
		db: db,
	}
}

// SaveResetToken guarda un token de reset de contraseña
func (r *PostgresPasswordResetRepository) SaveResetToken(ctx context.Context, token auth.PasswordResetToken) error {
	query := `
		INSERT INTO password_reset_tokens (
			id, token, user_id, expires_at, created_at, is_used
		) VALUES (
			:id, :token, :user_id, :expires_at, :created_at, :is_used
		)`

	_, err := r.db.NamedExecContext(ctx, query, token)
	if err != nil {
		return errx.Wrap(err, "failed to save reset token", errx.TypeInternal).
			WithDetail("user_id", token.UserID.String())
	}

	return nil
}

// FindResetToken busca un token de reset por su valor
func (r *PostgresPasswordResetRepository) FindResetToken(ctx context.Context, tokenValue string) (*auth.PasswordResetToken, error) {
	query := `
		SELECT 
			id, token, user_id, expires_at, created_at, is_used
		FROM password_reset_tokens 
		WHERE token = $1 AND is_used = false AND expires_at > NOW()`

	var token auth.PasswordResetToken
	err := r.db.GetContext(ctx, &token, query, tokenValue)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, errx.New("reset token not found or invalid", errx.TypeNotFound)
		}
		return nil, errx.Wrap(err, "failed to find reset token", errx.TypeInternal)
	}

	return &token, nil
}

// ConsumeResetToken marca un token como usado
func (r *PostgresPasswordResetRepository) ConsumeResetToken(ctx context.Context, tokenValue string) error {
	query := `
		UPDATE password_reset_tokens 
		SET is_used = true 
		WHERE token = $1 AND is_used = false AND expires_at > NOW()`

	result, err := r.db.ExecContext(ctx, query, tokenValue)
	if err != nil {
		return errx.Wrap(err, "failed to consume reset token", errx.TypeInternal)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return errx.New("reset token not found or already used", errx.TypeNotFound)
	}

	return nil
}

// CleanExpiredResetTokens limpia tokens expirados o usados (para mantenimiento)
func (r *PostgresPasswordResetRepository) CleanExpiredResetTokens(ctx context.Context) error {
	query := `
		DELETE FROM password_reset_tokens 
		WHERE expires_at < NOW() OR is_used = true`

	_, err := r.db.ExecContext(ctx, query)
	if err != nil {
		return errx.Wrap(err, "failed to clean expired reset tokens", errx.TypeInternal)
	}

	return nil
}

// RevokeAllUserResetTokens revoca todos los tokens de reset de un usuario
func (r *PostgresPasswordResetRepository) RevokeAllUserResetTokens(ctx context.Context, userID string) error {
	query := `
		UPDATE password_reset_tokens 
		SET is_used = true 
		WHERE user_id = $1 AND is_used = false`

	_, err := r.db.ExecContext(ctx, query, userID)
	if err != nil {
		return errx.Wrap(err, "failed to revoke all user reset tokens", errx.TypeInternal).
			WithDetail("user_id", userID)
	}

	return nil
}

// CountActiveResetTokens cuenta los tokens activos de reset de un usuario
func (r *PostgresPasswordResetRepository) CountActiveResetTokens(ctx context.Context, userID string) (int, error) {
	query := `
		SELECT COUNT(*) 
		FROM password_reset_tokens 
		WHERE user_id = $1 AND is_used = false AND expires_at > NOW()`

	var count int
	err := r.db.GetContext(ctx, &count, query, userID)
	if err != nil {
		return 0, errx.Wrap(err, "failed to count active reset tokens", errx.TypeInternal).
			WithDetail("user_id", userID)
	}

	return count, nil
}

// HasRecentResetToken verifica si un usuario tiene un token reciente (anti-spam)
func (r *PostgresPasswordResetRepository) HasRecentResetToken(ctx context.Context, userID string, withinMinutes int) (bool, error) {
	query := `
		SELECT EXISTS(
			SELECT 1 
			FROM password_reset_tokens 
			WHERE user_id = $1 
			AND created_at > NOW() - make_interval(mins => $2)
			AND is_used = false
		)`

	var exists bool
	err := r.db.GetContext(ctx, &exists, query, userID, withinMinutes)
	if err != nil {
		return false, errx.Wrap(err, "failed to check recent reset token", errx.TypeInternal).
			WithDetail("user_id", userID)
	}

	return exists, nil
}
package auth

import (
	"net/http"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
)

// ============================================================================
// Token Types
// ============================================================================

// RefreshToken representa un token de refresh
type RefreshToken struct {
	ID        string          `db:"id" json:"id"`
	Token     string          `db:"token" json:"token"`
	UserID    kernel.UserID   `db:"user_id" json:"user_id"`
	TenantID  kernel.TenantID `db:"tenant_id" json:"tenant_id"`
	ExpiresAt time.Time       `db:"expires_at" json:"expires_at"`
	CreatedAt time.Time       `db:"created_at" json:"created_at"`
	IsRevoked bool            `db:"is_revoked" json:"is_revoked"`
}

// UserSession representa una sesión de usuario
type UserSession struct {
	ID           string          `db:"id" json:"id"`
	UserID       kernel.UserID   `db:"user_id" json:"user_id"`
	TenantID     kernel.TenantID `db:"tenant_id" json:"tenant_id"`
	SessionToken string          `db:"session_token" json:"session_token"`
	IPAddress    string          `db:"ip_address" json:"ip_address"`
	UserAgent    string          `db:"user_agent" json:"user_agent"`
	ExpiresAt    time.Time       `db:"expires_at" json:"expires_at"`
	CreatedAt    time.Time       `db:"created_at" json:"created_at"`
	LastActivity time.Time       `db:"last_activity" json:"last_activity"`
}

// PasswordResetToken representa un token para resetear contraseña
type PasswordResetToken struct {
	ID        string        `db:"id" json:"id"`
	Token     string        `db:"token" json:"token"`
	UserID    kernel.UserID `db:"user_id" json:"user_id"`
	ExpiresAt time.Time     `db:"expires_at" json:"expires_at"`
	CreatedAt time.Time     `db:"created_at" json:"created_at"`
	IsUsed    bool          `db:"is_used" json:"is_used"`
}

// TokenClaims representa los claims de un JWT
type TokenClaims struct {
	UserID    kernel.UserID   `json:"user_id"`
	TenantID  kernel.TenantID `json:"tenant_id"`
	Email     string          `json:"email"`
	Name      string          `json:"name"`
	Scopes    []string        `json:"scopes"`
	IssuedAt  time.Time       `json:"iat"`
	ExpiresAt time.Time       `json:"exp"`
}

// ============================================================================
// Domain Methods
// ============================================================================

// IsExpired verifica si el refresh token ha expirado
func (r *RefreshToken) IsExpired() bool {
	return time.Now().After(r.ExpiresAt)
}

// IsValid verifica si el refresh token es válido
func (r *RefreshToken) IsValid() bool {
	return !r.IsRevoked && !r.IsExpired()
}

// IsExpired verifica si la sesión ha expirado
func (s *UserSession) IsExpired() bool {
	return time.Now().After(s.ExpiresAt)
}

// UpdateActivity actualiza la última actividad de la sesión
func (s *UserSession) UpdateActivity() {
	s.LastActivity = time.Now()
}

// IsExpired verifica si el token de reset ha expirado
func (p *PasswordResetToken) IsExpired() bool {
	return time.Now().After(p.ExpiresAt)
}

// IsValid verifica si el token de reset es válido
func (p *PasswordResetToken) IsValid() bool {
	return !p.IsUsed && !p.IsExpired()
}

// MarkAsUsed marca el token como usado
func (p *PasswordResetToken) MarkAsUsed() {
	p.IsUsed = true
}

// ============================================================================
// Error Registry - Errores específicos de Auth
// ============================================================================

var ErrRegistry = errx.NewRegistry("AUTH")

// Códigos de error
var (
	CodeInvalidRefreshToken      = ErrRegistry.Register("INVALID_REFRESH_TOKEN", errx.TypeAuthorization, http.StatusUnauthorized, "Refresh token inválido")
	CodeExpiredRefreshToken      = ErrRegistry.Register("EXPIRED_REFRESH_TOKEN", errx.TypeAuthorization, http.StatusUnauthorized, "Refresh token expirado")
	CodeInvalidOAuthProvider     = ErrRegistry.Register("INVALID_OAUTH_PROVIDER", errx.TypeValidation, http.StatusBadRequest, "Proveedor OAuth no válido")
	CodeOAuthAuthorizationFailed = ErrRegistry.Register("OAUTH_AUTHORIZATION_FAILED", errx.TypeExternal, http.StatusBadRequest, "Falló la autorización OAuth")
	CodeInvalidState             = ErrRegistry.Register("INVALID_STATE", errx.TypeValidation, http.StatusBadRequest, "Estado OAuth inválido")
	CodeTokenGenerationFailed    = ErrRegistry.Register("TOKEN_GENERATION_FAILED", errx.TypeInternal, http.StatusInternalServerError, "Error al generar token")
	CodeTokenValidationFailed    = ErrRegistry.Register("TOKEN_VALIDATION_FAILED", errx.TypeAuthorization, http.StatusUnauthorized, "Error al validar token")
	CodeOAuthCallbackError       = ErrRegistry.Register("OAUTH_CALLBACK_ERROR", errx.TypeExternal, http.StatusBadRequest, "Error en el callback OAuth")
)

// Helper functions para crear errores
func ErrInvalidRefreshToken() *errx.Error {
	return ErrRegistry.New(CodeInvalidRefreshToken)
}

func ErrExpiredRefreshToken() *errx.Error {
	return ErrRegistry.New(CodeExpiredRefreshToken)
}

func ErrInvalidOAuthProvider() *errx.Error {
	return ErrRegistry.New(CodeInvalidOAuthProvider)
}

func ErrOAuthAuthorizationFailed() *errx.Error {
	return ErrRegistry.New(CodeOAuthAuthorizationFailed)
}

func ErrInvalidState() *errx.Error {
	return ErrRegistry.New(CodeInvalidState)
}

func ErrTokenGenerationFailed() *errx.Error {
	return ErrRegistry.New(CodeTokenGenerationFailed)
}

func ErrTokenValidationFailed() *errx.Error {
	return ErrRegistry.New(CodeTokenValidationFailed)
}

func ErrOAuthCallbackError() *errx.Error {
	return ErrRegistry.New(CodeOAuthCallbackError)
}
package auth

import (
	"context"

	"github.com/Abraxas-365/manifesto/pkg/kernel"
)

// TokenRepository define el contrato para la persistencia de tokens
type TokenRepository interface {
	SaveRefreshToken(ctx context.Context, token RefreshToken) error
	FindRefreshToken(ctx context.Context, tokenValue string) (*RefreshToken, error)
	RevokeRefreshToken(ctx context.Context, tokenValue string) error
	RevokeAllUserTokens(ctx context.Context, userID kernel.UserID) error
	CleanExpiredTokens(ctx context.Context) error
}

// SessionRepository define el contrato para la persistencia de sesiones
type SessionRepository interface {
	SaveSession(ctx context.Context, session UserSession) error
	FindSession(ctx context.Context, sessionID string) (*UserSession, error)
	FindUserSessions(ctx context.Context, userID kernel.UserID) ([]*UserSession, error)
	UpdateSessionActivity(ctx context.Context, sessionID string) error
	RevokeSession(ctx context.Context, sessionID string) error
	RevokeAllUserSessions(ctx context.Context, userID kernel.UserID) error
	CleanExpiredSessions(ctx context.Context) error
}

// PasswordResetRepository define el contrato para tokens de reset de contraseña
type PasswordResetRepository interface {
	SaveResetToken(ctx context.Context, token PasswordResetToken) error
	FindResetToken(ctx context.Context, tokenValue string) (*PasswordResetToken, error)
	ConsumeResetToken(ctx context.Context, tokenValue string) error
	CleanExpiredResetTokens(ctx context.Context) error
}

// TokenService define el contrato para el manejo de tokens JWT
type TokenService interface {
	GenerateAccessToken(userID kernel.UserID, tenantID kernel.TenantID, claims map[string]any) (string, error)
	ValidateAccessToken(token string) (*TokenClaims, error)
	GenerateRefreshToken(userID kernel.UserID) (string, error)
}

// AuditService define el contrato para logs de autenticación
type AuditService interface {
	LogLoginAttempt(ctx context.Context, userID kernel.UserID, success bool, ipAddress string) error
	LogPasswordChange(ctx context.Context, userID kernel.UserID, ipAddress string) error
	LogTokenRefresh(ctx context.Context, userID kernel.UserID, ipAddress string) error
}

// Invitation representa una invitación (para evitar dependencia circular)
type Invitation interface {
	GetID() string
	GetTenantID() kernel.TenantID
	GetEmail() string
	CanBeAccepted() bool
	IsExpired() bool
	Accept(userID kernel.UserID) error
}
package auth

import (
	"context"
	"strings"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/config"
	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam"
	"github.com/Abraxas-365/manifesto/pkg/iam/invitation"
	"github.com/Abraxas-365/manifesto/pkg/iam/scopes"
	"github.com/Abraxas-365/manifesto/pkg/iam/tenant"
	"github.com/Abraxas-365/manifesto/pkg/iam/user"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/Abraxas-365/manifesto/pkg/ptrx"
	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
)

// AuthHandlers maneja las rutas de autenticación con Fiber
type AuthHandlers struct {
	oauthServices  map[iam.OAuthProvider]OAuthService
	tokenService   TokenService
	userRepo       user.UserRepository
	tenantRepo     tenant.TenantRepository
	tokenRepo      TokenRepository
	sessionRepo    SessionRepository
	stateManager   StateManager
	invitationRepo invitation.InvitationRepository
	config         *config.Config
}

// NewAuthHandlers crea un nuevo handler de autenticación
func NewAuthHandlers(
	oauthServices map[iam.OAuthProvider]OAuthService,
	tokenService TokenService,
	userRepo user.UserRepository,
	tenantRepo tenant.TenantRepository,
	tokenRepo TokenRepository,
	sessionRepo SessionRepository,
	stateManager StateManager,
	invitationRepo invitation.InvitationRepository,
	config *config.Config,
) *AuthHandlers {
	return &AuthHandlers{
		oauthServices:  oauthServices,
		tokenService:   tokenService,
		userRepo:       userRepo,
		tenantRepo:     tenantRepo,
		tokenRepo:      tokenRepo,
		sessionRepo:    sessionRepo,
		stateManager:   stateManager,
		invitationRepo: invitationRepo,
		config:         config,
	}
}

// LoginRequest estructura para iniciar login OAuth
type LoginRequest struct {
	Provider        iam.OAuthProvider `json:"provider"`
	InvitationToken string            `json:"invitation_token,omitempty"`
}

// LoginResponse respuesta del endpoint de login
type LoginResponse struct {
	AuthURL string `json:"auth_url"`
	State   string `json:"state"`
}

// TokenResponse respuesta con tokens de autenticación
type TokenResponse struct {
	AccessToken  string                  `json:"access_token"`
	RefreshToken string                  `json:"refresh_token"`
	TokenType    string                  `json:"token_type"`
	ExpiresIn    int                     `json:"expires_in"`
	User         user.UserDetailsDTO     `json:"user"`
	Tenant       tenant.TenantDetailsDTO `json:"tenant"`
}

// RefreshTokenRequest estructura para renovar token
type RefreshTokenRequest struct {
	RefreshToken string `json:"refresh_token"`
}

// RegisterRoutes registers the auth routes on Fiber
func (ah *AuthHandlers) RegisterRoutes(router fiber.Router) {
	auth := router.Group("/auth")

	auth.Post("/login", ah.InitiateLogin)
	auth.Get("/callback/:provider", ah.HandleCallback)
	auth.Post("/refresh", ah.RefreshToken)
	auth.Post("/logout", ah.Logout)
	auth.Get("/me", ah.GetCurrentUser)
}

// InitiateLogin inicia el proceso de login OAuth
func (ah *AuthHandlers) InitiateLogin(c *fiber.Ctx) error {
	var req LoginRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	// Normalizar el proveedor a mayúsculas y verificar que esté soportado
	normalizedProvider := iam.OAuthProvider(strings.ToUpper(string(req.Provider)))
	oauthService, exists := ah.oauthServices[normalizedProvider]
	if !exists {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": ErrInvalidOAuthProvider().Error(),
		})
	}

	// Generar estado OAuth
	state := ah.stateManager.GenerateState()

	// Almacenar información del estado
	stateData := map[string]interface{}{
		"provider": normalizedProvider,
	}
	if req.InvitationToken != "" {
		stateData["invitation_token"] = req.InvitationToken
	}

	if err := ah.stateManager.StoreState(c.Context(), state, stateData); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to store OAuth state",
		})
	}

	// Generar URL de autorización
	authURL := oauthService.GetAuthURL(state)

	return c.JSON(LoginResponse{
		AuthURL: authURL,
		State:   state,
	})
}

// HandleCallback maneja el callback OAuth
func (ah *AuthHandlers) HandleCallback(c *fiber.Ctx) error {
	providerStr := c.Params("provider")

	// Convertir string a OAuthProvider
	var provider iam.OAuthProvider
	switch providerStr {
	case "google":
		provider = iam.OAuthProviderGoogle
	case "microsoft":
		provider = iam.OAuthProviderMicrosoft
	default:
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": ErrInvalidOAuthProvider().Error(),
		})
	}

	// Verificar que el servicio OAuth exista
	oauthService, exists := ah.oauthServices[provider]
	if !exists {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": ErrInvalidOAuthProvider().Error(),
		})
	}

	// Obtener parámetros del callback
	code := c.Query("code")
	state := c.Query("state")
	errorParam := c.Query("error")

	// Verificar errores OAuth
	if errorParam != "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": ErrOAuthCallbackError().WithDetail("error", errorParam).Error(),
		})
	}

	if code == "" || state == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Missing code or state parameter",
		})
	}

	// Validar estado
	stateData, err := ah.stateManager.GetStateData(c.Context(), state)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": ErrInvalidState().Error(),
		})
	}

	// Intercambiar código por token
	tokenResp, err := oauthService.ExchangeToken(c.Context(), code)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// Obtener información del usuario
	userInfo, err := oauthService.GetUserInfo(c.Context(), tokenResp.AccessToken)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// Buscar o crear usuario
	userEntity, tenantEntity, err := ah.findOrCreateUser(c.Context(), userInfo, provider, stateData)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// Generar tokens de nuestra aplicación
	accessToken, err := ah.tokenService.GenerateAccessToken(userEntity.ID, tenantEntity.ID, map[string]any{
		"email":  userEntity.Email,
		"name":   userEntity.Name,
		"scopes": userEntity.Scopes,
	})
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	refreshTokenStr, err := ah.tokenService.GenerateRefreshToken(userEntity.ID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// Guardar refresh token en base de datos
	refreshToken := RefreshToken{
		ID:        generateID(),
		Token:     refreshTokenStr,
		UserID:    userEntity.ID,
		TenantID:  tenantEntity.ID,
		ExpiresAt: time.Now().Add(ah.config.Auth.JWT.RefreshTokenTTL),
		CreatedAt: time.Now(),
		IsRevoked: false,
	}

	if err := ah.tokenRepo.SaveRefreshToken(c.Context(), refreshToken); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to save refresh token",
		})
	}

	// Crear sesión de usuario
	session := UserSession{
		ID:           generateID(),
		UserID:       userEntity.ID,
		TenantID:     tenantEntity.ID,
		SessionToken: generateID(),
		IPAddress:    c.IP(),
		UserAgent:    c.Get("User-Agent"),
		ExpiresAt:    time.Now().Add(ah.config.Auth.JWT.RefreshTokenTTL),
		CreatedAt:    time.Now(),
		LastActivity: time.Now(),
	}

	if err := ah.sessionRepo.SaveSession(c.Context(), session); err != nil {
		// Log error pero no fallar la autenticación
	}

	// Actualizar último login del usuario
	userEntity.UpdateLastLogin()
	if err := ah.userRepo.Save(c.Context(), *userEntity); err != nil {
		// Log error pero no fallar
	}

	response := TokenResponse{
		AccessToken:  accessToken,
		RefreshToken: refreshTokenStr,
		TokenType:    "Bearer",
		ExpiresIn:    int(ah.config.Auth.JWT.AccessTokenTTL / time.Second),
		User:         userEntity.ToDTO(),
		Tenant:       tenantEntity.ToDTO(),
	}

	// Set cookies for browser-based apps
	c.Cookie(&fiber.Cookie{
		Name:     ah.config.Auth.Cookie.AccessTokenName,
		Value:    accessToken,
		Expires:  time.Now().Add(ah.config.Auth.JWT.AccessTokenTTL),
		HTTPOnly: ah.config.Auth.Cookie.HTTPOnly,
		Secure:   ah.config.Auth.Cookie.Secure,
		SameSite: ah.config.Auth.Cookie.SameSite,
		Domain:   ah.config.Auth.Cookie.Domain,
		Path:     ah.config.Auth.Cookie.Path,
	})

	c.Cookie(&fiber.Cookie{
		Name:     ah.config.Auth.Cookie.RefreshTokenName,
		Value:    refreshTokenStr,
		Expires:  time.Now().Add(ah.config.Auth.JWT.RefreshTokenTTL),
		HTTPOnly: ah.config.Auth.Cookie.HTTPOnly,
		Secure:   ah.config.Auth.Cookie.Secure,
		SameSite: ah.config.Auth.Cookie.SameSite,
		Domain:   ah.config.Auth.Cookie.Domain,
		Path:     ah.config.Auth.Cookie.Path,
	})

	return c.JSON(response)
}

// RefreshToken renueva un access token usando refresh token
func (ah *AuthHandlers) RefreshToken(c *fiber.Ctx) error {
	var req RefreshTokenRequest

	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	// Alternativamente, obtener refresh token de cookie
	if req.RefreshToken == "" {
		req.RefreshToken = c.Cookies("refresh_token")
	}

	if req.RefreshToken == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "refresh_token is required",
		})
	}

	// Buscar refresh token en base de datos
	refreshToken, err := ah.tokenRepo.FindRefreshToken(c.Context(), req.RefreshToken)
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": ErrInvalidRefreshToken().Error(),
		})
	}

	// Verificar validez del refresh token
	if !refreshToken.IsValid() {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": ErrExpiredRefreshToken().Error(),
		})
	}

	// Buscar usuario y tenant
	userEntity, err := ah.userRepo.FindByID(c.Context(), refreshToken.UserID, refreshToken.TenantID)
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "User not found",
		})
	}

	tenantEntity, err := ah.tenantRepo.FindByID(c.Context(), refreshToken.TenantID)
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "Tenant not found",
		})
	}

	// Verificar que el usuario pueda hacer login
	if !userEntity.CanLogin() {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "User cannot login",
		})
	}

	// Verificar que el tenant esté activo
	if !tenantEntity.IsActive() {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "Tenant is not active",
		})
	}

	// Generar nuevo access token
	accessToken, err := ah.tokenService.GenerateAccessToken(userEntity.ID, tenantEntity.ID, map[string]any{
		"email":  userEntity.Email,
		"name":   userEntity.Name,
		"scopes": userEntity.Scopes,
	})
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// Update access token cookie
	c.Cookie(&fiber.Cookie{
		Name:     "access_token",
		Value:    accessToken,
		Expires:  time.Now().Add(15 * time.Minute),
		HTTPOnly: true,
		Secure:   true,
		SameSite: "Lax",
	})

	return c.JSON(fiber.Map{
		"access_token": accessToken,
		"token_type":   "Bearer",
		"expires_in":   int(15 * time.Minute / time.Second),
	})
}

// Logout invalida tokens y sesiones del usuario
func (ah *AuthHandlers) Logout(c *fiber.Ctx) error {
	// Intentar obtener contexto de auth del middleware
	authContext, ok := GetAuthContext(c)
	if !ok {
		// Fallback: intentar decodificar el token
		var token string
		authHeader := c.Get("Authorization")
		if authHeader != "" {
			parts := strings.SplitN(authHeader, " ", 2)
			if len(parts) == 2 && parts[0] == "Bearer" && parts[1] != "" {
				token = parts[1]
			}
		}
		if token == "" {
			token = c.Cookies("access_token")
		}
		if token == "" {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": iam.ErrUnauthorized().Error(),
			})
		}
		claims, err := ah.tokenService.ValidateAccessToken(token)
		if err != nil {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": iam.ErrUnauthorized().Error(),
			})
		}
		authContext = &kernel.AuthContext{
			UserID:   &claims.UserID,
			TenantID: claims.TenantID,
			Email:    claims.Email,
			Name:     claims.Name,
			Scopes:   claims.Scopes,
			IsAPIKey: false,
		}
	}

	if authContext.UserID == nil {
		return iam.ErrUnauthorized()
	}

	// Revocar todos los refresh tokens del usuario
	if err := ah.tokenRepo.RevokeAllUserTokens(c.Context(), *authContext.UserID); err != nil {
		// Log error pero no fallar
	}

	// Revocar todas las sesiones del usuario
	if err := ah.sessionRepo.RevokeAllUserSessions(c.Context(), *authContext.UserID); err != nil {
		// Log error pero no fallar
	}

	// Clear cookies
	c.Cookie(&fiber.Cookie{
		Name:     "access_token",
		Value:    "",
		Expires:  time.Now().Add(-time.Hour),
		HTTPOnly: true,
	})

	c.Cookie(&fiber.Cookie{
		Name:     "refresh_token",
		Value:    "",
		Expires:  time.Now().Add(-time.Hour),
		HTTPOnly: true,
	})

	return c.JSON(fiber.Map{
		"message": "Logged out successfully",
	})
}

// GetCurrentUser obtiene la información del usuario autenticado
func (ah *AuthHandlers) GetCurrentUser(c *fiber.Ctx) error {
	authContext, ok := GetAuthContext(c)
	if !ok {
		// Fallback: intentar decodificar el token
		var token string
		authHeader := c.Get("Authorization")
		if authHeader != "" {
			parts := strings.SplitN(authHeader, " ", 2)
			if len(parts) == 2 && parts[0] == "Bearer" && parts[1] != "" {
				token = parts[1]
			}
		}
		if token == "" {
			token = c.Cookies("access_token")
		}
		if token == "" {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": iam.ErrUnauthorized().Error(),
			})
		}
		claims, err := ah.tokenService.ValidateAccessToken(token)
		if err != nil {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": iam.ErrUnauthorized().Error(),
			})
		}
		authContext = &kernel.AuthContext{
			UserID:   &claims.UserID,
			TenantID: claims.TenantID,
			Email:    claims.Email,
			Name:     claims.Name,
			Scopes:   claims.Scopes,
			IsAPIKey: false,
		}
	}

	if authContext.UserID == nil {
		return iam.ErrUnauthorized()
	}

	// Buscar usuario completo
	userEntity, err := ah.userRepo.FindByID(c.Context(), *authContext.UserID, authContext.TenantID)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": "User not found",
		})
	}

	// Buscar tenant
	tenantEntity, err := ah.tenantRepo.FindByID(c.Context(), authContext.TenantID)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": "Tenant not found",
		})
	}

	return c.JSON(fiber.Map{
		"user":   userEntity.ToDTO(),
		"tenant": tenantEntity.ToDTO(),
	})
}

// 🔥 findOrCreateUser WITH ACCOUNT LINKING
func (ah *AuthHandlers) findOrCreateUser(ctx context.Context, userInfo *OAuthUserInfo, provider iam.OAuthProvider, stateData map[string]interface{}) (*user.User, *tenant.Tenant, error) {
	var tenantEntity *tenant.Tenant
	var invitationToken string
	var invitationScopes []string
	var err error

	// Verificar si hay un token de invitación
	if token, ok := stateData["invitation_token"].(string); ok && token != "" {
		invitationToken = token
	}

	// Si hay token de invitación, validarlo y obtener el tenant
	if invitationToken != "" {
		inv, err := ah.invitationRepo.FindByToken(ctx, invitationToken)
		if err != nil {
			return nil, nil, errx.New("invalid invitation token", errx.TypeBusiness)
		}

		if !inv.CanBeAccepted() {
			if inv.IsExpired() {
				return nil, nil, errx.New("invitation expired", errx.TypeBusiness)
			}
			return nil, nil, errx.New("invitation not valid", errx.TypeBusiness)
		}

		if inv.GetEmail() != userInfo.Email {
			return nil, nil, errx.New("email does not match invitation", errx.TypeBusiness)
		}

		invitationScopes = inv.GetScopes()

		tenantEntity, err = ah.tenantRepo.FindByID(ctx, inv.GetTenantID())
		if err != nil {
			return nil, nil, tenant.ErrTenantNotFound()
		}
	} else {
		return nil, nil, errx.New("invitation required for registration", errx.TypeAuthorization)
	}

	// 🔥 ACCOUNT LINKING: Buscar usuario existente
	existingUser, err := ah.userRepo.FindByEmail(ctx, userInfo.Email, tenantEntity.ID)
	if err == nil {
		// Usuario existe - link OAuth if not already linked
		if existingUser.OAuthProvider != provider || existingUser.OAuthProviderID != userInfo.ID {
			existingUser.LinkOAuth(provider, userInfo.ID)
			existingUser.UpdateProfile(userInfo.Name, userInfo.Picture)

			if err := ah.userRepo.Save(ctx, *existingUser); err != nil {
				return nil, nil, err
			}
		}
		return existingUser, tenantEntity, nil
	}

	// Verificar si el tenant puede agregar más usuarios
	if !tenantEntity.CanAddUser() {
		return nil, nil, tenant.ErrMaxUsersReached()
	}

	// Determine scopes
	var userScopes []string
	if len(invitationScopes) > 0 {
		userScopes = invitationScopes
	} else {
		userScopes = scopes.GetScopesByGroup("viewer")
	}

	// 🔥 Crear nuevo usuario con OAuth (OTPEnabled = false por defecto)
	newUser := &user.User{
		ID:              kernel.NewUserID(generateID()),
		TenantID:        tenantEntity.ID,
		Email:           userInfo.Email,
		Name:            userInfo.Name,
		Picture:         ptrx.String(userInfo.Picture),
		Status:          user.UserStatusActive,
		Scopes:          userScopes,
		OAuthProvider:   provider,
		OAuthProviderID: userInfo.ID,
		OTPEnabled:      false, // 🔥 OAuth users don't have OTP by default
		EmailVerified:   userInfo.EmailVerified,
		CreatedAt:       time.Now(),
		UpdatedAt:       time.Now(),
	}

	// Guardar usuario
	if err := ah.userRepo.Save(ctx, *newUser); err != nil {
		return nil, nil, err
	}

	// Incrementar contador de usuarios del tenant
	if err := tenantEntity.AddUser(); err != nil {
		ah.userRepo.Delete(ctx, newUser.ID, tenantEntity.ID)
		return nil, nil, err
	}

	// Guardar tenant actualizado
	if err := ah.tenantRepo.Save(ctx, *tenantEntity); err != nil {
		// Log error pero no fallar
	}

	// Accept the invitation
	if invitationToken != "" {
		inv, err := ah.invitationRepo.FindByToken(ctx, invitationToken)
		if err == nil {
			if err := inv.Accept(newUser.ID); err == nil {
				ah.invitationRepo.Save(ctx, *inv)
			}
		}
	}

	return newUser, tenantEntity, nil
}

// Helper functions
func generateID() string {
	return uuid.NewString()
}
package auth

import (
	"fmt"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/config"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/golang-jwt/jwt/v5"
)

// JWTService implementación del TokenService usando JWT
type JWTService struct {
	secretKey       []byte
	accessTokenTTL  time.Duration
	refreshTokenTTL time.Duration
	issuer          string
	audience        []string
}

// NewJWTService crea una nueva instancia del servicio JWT
func NewJWTServiceFromConfig(cfg *config.JWTConfig) *JWTService {
	return &JWTService{
		secretKey:       []byte(cfg.SecretKey),
		accessTokenTTL:  cfg.AccessTokenTTL,
		refreshTokenTTL: cfg.RefreshTokenTTL,
		issuer:          cfg.Issuer,
		audience:        cfg.Audience,
	}
}

// Claims personalizados para JWT
type JWTClaims struct {
	UserID   kernel.UserID   `json:"user_id"`
	TenantID kernel.TenantID `json:"tenant_id"`
	Email    string          `json:"email"`
	Name     string          `json:"name"`
	Scopes   []string        `json:"scopes"`
	jwt.RegisteredClaims
}

// GenerateAccessToken genera un token de acceso JWT
func (j *JWTService) GenerateAccessToken(userID kernel.UserID, tenantID kernel.TenantID, claims map[string]any) (string, error) {
	now := time.Now()

	// Extraer claims adicionales
	email, _ := claims["email"].(string)
	name, _ := claims["name"].(string)
	scopes, _ := claims["scopes"].([]string)

	// Default to empty scopes if not provided
	if scopes == nil {
		scopes = []string{}
	}

	jwtClaims := JWTClaims{
		UserID:   userID,
		TenantID: tenantID,
		Email:    email,
		Name:     name,
		Scopes:   scopes,
		RegisteredClaims: jwt.RegisteredClaims{
			Issuer:    j.issuer,
			Subject:   userID.String(),
			Audience:  j.audience,
			ExpiresAt: jwt.NewNumericDate(now.Add(j.accessTokenTTL)),
			NotBefore: jwt.NewNumericDate(now),
			IssuedAt:  jwt.NewNumericDate(now),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwtClaims)

	tokenString, err := token.SignedString(j.secretKey)
	if err != nil {
		return "", ErrTokenGenerationFailed().WithDetail("error", err.Error())
	}

	return tokenString, nil
}

// ValidateAccessToken valida y decodifica un token de acceso
func (j *JWTService) ValidateAccessToken(tokenString string) (*TokenClaims, error) {
	token, err := jwt.ParseWithClaims(tokenString, &JWTClaims{}, func(token *jwt.Token) (any, error) {
		// Verificar el método de firma
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}
		return j.secretKey, nil
	})

	if err != nil {
		return nil, ErrTokenValidationFailed().WithDetail("error", err.Error())
	}

	if !token.Valid {
		return nil, ErrTokenValidationFailed().WithDetail("error", "token is invalid")
	}

	jwtClaims, ok := token.Claims.(*JWTClaims)
	if !ok {
		return nil, ErrTokenValidationFailed().WithDetail("error", "invalid claims type")
	}

	return &TokenClaims{
		UserID:    jwtClaims.UserID,
		TenantID:  jwtClaims.TenantID,
		Email:     jwtClaims.Email,
		Name:      jwtClaims.Name,
		Scopes:    jwtClaims.Scopes,
		IssuedAt:  jwtClaims.IssuedAt.Time,
		ExpiresAt: jwtClaims.ExpiresAt.Time,
	}, nil
}

// GenerateRefreshToken genera un token de refresh simple
func (j *JWTService) GenerateRefreshToken(userID kernel.UserID) (string, error) {
	now := time.Now()

	claims := jwt.RegisteredClaims{
		Issuer:    j.issuer,
		Subject:   userID.String(),
		Audience:  j.audience,
		ExpiresAt: jwt.NewNumericDate(now.Add(j.refreshTokenTTL)),
		NotBefore: jwt.NewNumericDate(now),
		IssuedAt:  jwt.NewNumericDate(now),
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	tokenString, err := token.SignedString(j.secretKey)
	if err != nil {
		return "", ErrTokenGenerationFailed().WithDetail("error", err.Error())
	}

	return tokenString, nil
}
package auth

import (
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/gofiber/fiber/v2"
)

// ProtectedRoutes helper para configurar rutas protegidas
type ProtectedRoutes struct {
	authMiddleware *TokenMiddleware
}

// NewProtectedRoutes crea un nuevo helper para rutas protegidas
func NewProtectedRoutes(authMiddleware *TokenMiddleware) *ProtectedRoutes {
	return &ProtectedRoutes{
		authMiddleware: authMiddleware,
	}
}

// SetupProtectedRoutes configura rutas protegidas
func (pr *ProtectedRoutes) SetupProtectedRoutes(app *fiber.App) {
	// Rutas públicas
	public := app.Group("/api/public")
	public.Get("/health", func(c *fiber.Ctx) error {
		return c.JSON(fiber.Map{"status": "OK"})
	})

	// Rutas protegidas (requieren autenticación)
	protected := app.Group("/api")
	protected.Use(pr.authMiddleware.Authenticate())

	// Rutas específicas de usuario autenticado
	protected.Get("/me", func(c *fiber.Ctx) error {
		authContext, _ := GetAuthContext(c)
		return c.JSON(fiber.Map{
			"user_id":   authContext.UserID,
			"tenant_id": authContext.TenantID,
			"email":     authContext.Email,
			"name":      authContext.Name,
			"scopes":    authContext.Scopes,
			"is_admin":  authContext.IsAdmin(),
		})
	})

	// Rutas de administración (requieren admin)
	admin := protected.Group("/admin")
	admin.Use(pr.authMiddleware.RequireAdmin())

	admin.Get("/users", func(c *fiber.Ctx) error {
		return c.JSON(fiber.Map{"message": "Admin users endpoint"})
	})

	admin.Get("/tenants", func(c *fiber.Ctx) error {
		return c.JSON(fiber.Map{"message": "Admin tenants endpoint"})
	})

	// Rutas por tenant
	tenant := protected.Group("/tenant/:tenantId")
	tenant.Use(pr.ValidateTenantAccess())

	tenant.Get("/dashboard", func(c *fiber.Ctx) error {
		return c.JSON(fiber.Map{"message": "Tenant dashboard"})
	})
}

// ValidateTenantAccess middleware para validar acceso a tenant específico
func (pr *ProtectedRoutes) ValidateTenantAccess() fiber.Handler {
	return func(c *fiber.Ctx) error {
		tenantIDParam := c.Params("tenantId")
		authContext, ok := GetAuthContext(c)
		if !ok {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": "Authentication required",
			})
		}

		// Verificar que el usuario tenga acceso al tenant
		if authContext.TenantID.String() != tenantIDParam && !authContext.IsAdmin() {
			return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
				"error": "Access denied to this tenant",
			})
		}

		// Agregar tenant ID al contexto
		c.Locals("tenant_id", kernel.NewTenantID(tenantIDParam))
		return c.Next()
	}
}

func ValidateTenantAccess() fiber.Handler {
	return func(c *fiber.Ctx) error {
		tenantIDParam := c.Params("tenantId")
		authContext, ok := GetAuthContext(c)
		if !ok {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": "Authentication required",
			})
		}

		// Verificar que el usuario tenga acceso al tenant
		// Los admins pueden acceder a cualquier tenant
		if authContext.TenantID.String() != tenantIDParam && !authContext.IsAdmin() {
			return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
				"error": "Access denied to this tenant",
			})
		}

		// Agregar tenant ID al contexto para uso en handlers
		c.Locals("tenant_id", kernel.NewTenantID(tenantIDParam))
		return c.Next()
	}
}

// GetTenantID obtiene el tenant ID del contexto
// Helper function para usar en los handlers
func GetTenantID(c *fiber.Ctx) (kernel.TenantID, bool) {
	tenantID, ok := c.Locals("tenant_id").(kernel.TenantID)
	return tenantID, ok
}

func GetUserID(c *fiber.Ctx) (kernel.UserID, bool) {
	userID, ok := c.Locals("user_id").(kernel.UserID)
	return userID, ok
}
package auth

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/Abraxas-365/manifesto/pkg/config"
	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam"
)

const (
	MicrosoftAuthURL     = "https://login.microsoftonline.com/common/oauth2/v2.0/authorize"
	MicrosoftTokenURL    = "https://login.microsoftonline.com/common/oauth2/v2.0/token"
	MicrosoftUserInfoURL = "https://graph.microsoft.com/v1.0/me"
)

// MicrosoftOAuthService implementación del servicio OAuth para Microsoft
type MicrosoftOAuthService struct {
	config       OAuthConfig
	httpClient   *http.Client
	stateManager StateManager
	authURL      string
	tokenURL     string
	userInfoURL  string
}

// NewMicrosoftOAuthService crea una nueva instancia del servicio Microsoft OAuth
func NewMicrosoftOAuthServiceFromConfig(cfg *config.OAuthProviderConfig, stateManager StateManager) *MicrosoftOAuthService {
	return &MicrosoftOAuthService{
		config: OAuthConfig{
			ClientID:     cfg.ClientID,
			ClientSecret: cfg.ClientSecret,
			RedirectURL:  cfg.RedirectURL,
			Scopes:       cfg.Scopes,
		},
		httpClient:   &http.Client{Timeout: cfg.Timeout},
		stateManager: stateManager,
		authURL:      cfg.AuthURL,
		tokenURL:     cfg.TokenURL,
		userInfoURL:  cfg.UserInfoURL,
	}
}

// GetProvider retorna el proveedor OAuth
func (m *MicrosoftOAuthService) GetProvider() iam.OAuthProvider {
	return iam.OAuthProviderMicrosoft
}

// GetAuthURL genera la URL de autorización de Microsoft
func (m *MicrosoftOAuthService) GetAuthURL(state string) string {
	params := url.Values{
		"client_id":     {m.config.ClientID},
		"redirect_uri":  {m.config.RedirectURL},
		"scope":         {strings.Join(m.config.Scopes, " ")},
		"response_type": {"code"},
		"state":         {state},
		"response_mode": {"query"},
	}

	return fmt.Sprintf("%s?%s", MicrosoftAuthURL, params.Encode())
}

// ValidateState valida el estado OAuth
func (m *MicrosoftOAuthService) ValidateState(state string) bool {
	return m.stateManager.ValidateState(state)
}

// ExchangeToken intercambia el código de autorización por tokens
func (m *MicrosoftOAuthService) ExchangeToken(ctx context.Context, code string) (*OAuthTokenResponse, error) {
	data := url.Values{
		"client_id":     {m.config.ClientID},
		"client_secret": {m.config.ClientSecret},
		"code":          {code},
		"grant_type":    {"authorization_code"},
		"redirect_uri":  {m.config.RedirectURL},
	}

	req, err := http.NewRequestWithContext(ctx, "POST", MicrosoftTokenURL, strings.NewReader(data.Encode()))
	if err != nil {
		return nil, errx.Wrap(err, "failed to create token request", errx.TypeInternal)
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	resp, err := m.httpClient.Do(req)
	if err != nil {
		return nil, errx.Wrap(err, "failed to exchange token", errx.TypeExternal)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, ErrOAuthAuthorizationFailed().
			WithDetail("status_code", resp.StatusCode).
			WithDetail("provider", "microsoft")
	}

	var tokenResp OAuthTokenResponse
	if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
		return nil, errx.Wrap(err, "failed to decode token response", errx.TypeExternal)
	}

	return &tokenResp, nil
}

// GetUserInfo obtiene la información del usuario desde Microsoft
func (m *MicrosoftOAuthService) GetUserInfo(ctx context.Context, accessToken string) (*OAuthUserInfo, error) {
	req, err := http.NewRequestWithContext(ctx, "GET", MicrosoftUserInfoURL, nil)
	if err != nil {
		return nil, errx.Wrap(err, "failed to create user info request", errx.TypeInternal)
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)

	resp, err := m.httpClient.Do(req)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get user info", errx.TypeExternal)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, ErrOAuthAuthorizationFailed().
			WithDetail("status_code", resp.StatusCode).
			WithDetail("provider", "microsoft").
			WithDetail("endpoint", "userinfo")
	}

	var msUser struct {
		ID                string `json:"id"`
		Mail              string `json:"mail"`
		UserPrincipalName string `json:"userPrincipalName"`
		DisplayName       string `json:"displayName"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&msUser); err != nil {
		return nil, errx.Wrap(err, "failed to decode user info", errx.TypeExternal)
	}

	// Microsoft puede usar mail o userPrincipalName como email
	email := msUser.Mail
	if email == "" {
		email = msUser.UserPrincipalName
	}

	return &OAuthUserInfo{
		ID:            msUser.ID,
		Email:         email,
		Name:          msUser.DisplayName,
		Picture:       "",   // Microsoft Graph requiere endpoint separado para foto
		EmailVerified: true, // Asumimos verificado si viene de Microsoft
	}, nil
}
package auth

import (
	"strings"

	"github.com/Abraxas-365/manifesto/pkg/iam"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/gofiber/fiber/v2"
)

// TokenMiddleware middleware para autenticación JWT con Fiber
type TokenMiddleware struct {
	tokenService TokenService
}

// NewAuthMiddleware crea un nuevo middleware de autenticación
func NewAuthMiddleware(tokenService TokenService) *TokenMiddleware {
	return &TokenMiddleware{
		tokenService: tokenService,
	}
}

// Authenticate middleware que valida tokens JWT
func (am *TokenMiddleware) Authenticate() fiber.Handler {
	return func(c *fiber.Ctx) error {
		// Extraer token del header Authorization o cookie de acceso
		authHeader := c.Get("Authorization")
		var token string

		if authHeader != "" {
			// Verificar formato "Bearer <token>"
			parts := strings.SplitN(authHeader, " ", 2)
			if len(parts) == 2 && parts[0] == "Bearer" && parts[1] != "" {
				token = parts[1]
			} else {
				// Fallback: intentar con cookie "access_token" si el header es inválido
				token = c.Cookies("access_token")
				if token == "" {
					return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
						"error": iam.ErrInvalidToken().Error(),
					})
				}
			}
		} else {
			// Fallback: intentar con cookie "access_token"
			token = c.Cookies("access_token")
			if token == "" {
				return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
					"error": iam.ErrUnauthorized().Error(),
				})
			}
		}

		// Validar token
		claims, err := am.tokenService.ValidateAccessToken(token)
		if err != nil {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": err.Error(),
			})
		}

		// Crear contexto de autenticación
		authContext := &kernel.AuthContext{
			UserID:   &claims.UserID,
			TenantID: claims.TenantID,
			Email:    claims.Email,
			Name:     claims.Name,
			Scopes:   claims.Scopes,
			IsAPIKey: false,
		}

		// Agregar al contexto de Fiber
		c.Locals("auth", authContext)

		return c.Next()
	}
}

// RequireAdmin middleware que requiere permisos de administrador
func (am *TokenMiddleware) RequireAdmin() fiber.Handler {
	return func(c *fiber.Ctx) error {
		authContext, ok := c.Locals("auth").(*kernel.AuthContext)
		if !ok || authContext == nil {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": iam.ErrUnauthorized().Error(),
			})
		}

		if !authContext.IsAdmin() {
			return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
				"error": iam.ErrAccessDenied().Error(),
			})
		}

		return c.Next()
	}
}

// RequireTenant middleware que valida acceso al tenant
func (am *TokenMiddleware) RequireTenant(tenantID kernel.TenantID) fiber.Handler {
	return func(c *fiber.Ctx) error {
		authContext, ok := c.Locals("auth").(*kernel.AuthContext)
		if !ok || authContext == nil {
			return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
				"error": iam.ErrUnauthorized().Error(),
			})
		}

		if authContext.TenantID != tenantID {
			return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
				"error": "Access denied for this tenant",
			})
		}

		return c.Next()
	}
}
// pkg/auth/oauth.go
package auth

import (
	"context"

	"github.com/Abraxas-365/manifesto/pkg/iam"
)

// ============================================================================
// OAuth Types
// ============================================================================

// OAuthUserInfo información del usuario desde el proveedor OAuth
type OAuthUserInfo struct {
	ID            string `json:"id"`
	Email         string `json:"email"`
	Name          string `json:"name"`
	Picture       string `json:"picture"`
	EmailVerified bool   `json:"email_verified"`
}

// OAuthService define el contrato para servicios OAuth
type OAuthService interface {
	GetAuthURL(state string) string
	ExchangeToken(ctx context.Context, code string) (*OAuthTokenResponse, error)
	GetUserInfo(ctx context.Context, accessToken string) (*OAuthUserInfo, error)
	ValidateState(state string) bool
	GetProvider() iam.OAuthProvider
}

// OAuthTokenResponse respuesta del intercambio de código por token
type OAuthTokenResponse struct {
	AccessToken  string `json:"access_token"`
	TokenType    string `json:"token_type"`
	RefreshToken string `json:"refresh_token,omitempty"`
	ExpiresIn    int    `json:"expires_in"`
}

// StateManager maneja la validación de estados OAuth
type StateManager interface {
	GenerateState() string
	ValidateState(state string) bool
	StoreState(ctx context.Context, state string, data map[string]any) error
	GetStateData(ctx context.Context, state string) (map[string]any, error)
}
package auth

import (
	"fmt"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/config"
	"github.com/Abraxas-365/manifesto/pkg/iam"
	"github.com/Abraxas-365/manifesto/pkg/iam/invitation"
	"github.com/Abraxas-365/manifesto/pkg/iam/otp"
	"github.com/Abraxas-365/manifesto/pkg/iam/otp/otpsrv"
	"github.com/Abraxas-365/manifesto/pkg/iam/tenant"
	"github.com/Abraxas-365/manifesto/pkg/iam/user"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
)

// PasswordlessAuthHandlers handles OTP-based passwordless authentication
type PasswordlessAuthHandlers struct {
	tokenService   TokenService
	userRepo       user.UserRepository
	tenantRepo     tenant.TenantRepository
	tokenRepo      TokenRepository
	sessionRepo    SessionRepository
	invitationRepo invitation.InvitationRepository
	otpService     *otpsrv.OTPService
	config         *config.Config
}

func NewPasswordlessAuthHandlers(
	tokenService TokenService,
	userRepo user.UserRepository,
	tenantRepo tenant.TenantRepository,
	tokenRepo TokenRepository,
	sessionRepo SessionRepository,
	invitationRepo invitation.InvitationRepository,
	otpService *otpsrv.OTPService,
	config *config.Config,
) *PasswordlessAuthHandlers {
	return &PasswordlessAuthHandlers{
		tokenService:   tokenService,
		userRepo:       userRepo,
		tenantRepo:     tenantRepo,
		tokenRepo:      tokenRepo,
		sessionRepo:    sessionRepo,
		invitationRepo: invitationRepo,
		otpService:     otpService,
		config:         config,
	}
}

// RegisterRoutes registers passwordless auth routes
func (h *PasswordlessAuthHandlers) RegisterRoutes(router fiber.Router) {
	auth := router.Group("/auth/passwordless")

	// Tenant lookup (public - before login)
	auth.Post("/tenants", h.GetUserTenants)

	// Signup flow
	auth.Post("/signup/initiate", h.InitiateSignup)
	auth.Post("/signup/verify", h.VerifySignup)

	// Login flow
	auth.Post("/login/initiate", h.InitiateLogin)
	auth.Post("/login/verify", h.VerifyLogin)

	// Utility
	auth.Post("/resend-otp", h.ResendOTP)
}

// ============================================================================
// TENANT LOOKUP (for multi-tenant user selection)
// ============================================================================

// GetUserTenantsRequest to find tenants for an email
type GetUserTenantsRequest struct {
	Email string `json:"email" validate:"required,email"`
}

// TenantOption represents a tenant the user belongs to
type TenantOption struct {
	TenantID    kernel.TenantID `json:"tenant_id"`
	CompanyName string          `json:"company_name"`
	UserStatus  user.UserStatus `json:"user_status"`
	AuthMethods struct {
		OTP      bool              `json:"otp"`
		OAuth    bool              `json:"oauth"`
		Provider iam.OAuthProvider `json:"oauth_provider,omitempty"`
	} `json:"auth_methods"`
}

type GetUserTenantsResponse struct {
	Email   string         `json:"email"`
	Tenants []TenantOption `json:"tenants"`
	Count   int            `json:"count"`
}

// GetUserTenants returns all tenants where this email has an account
func (h *PasswordlessAuthHandlers) GetUserTenants(c *fiber.Ctx) error {
	var req GetUserTenantsRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	// Find all users with this email across tenants
	users, err := h.userRepo.FindByEmailAcrossTenants(c.Context(), req.Email)
	if err != nil || len(users) == 0 {
		// Don't reveal if email exists - return empty list
		return c.JSON(GetUserTenantsResponse{
			Email:   req.Email,
			Tenants: []TenantOption{},
			Count:   0,
		})
	}

	// Build tenant options
	tenantOptions := make([]TenantOption, 0, len(users))
	for _, u := range users {
		tenantEntity, err := h.tenantRepo.FindByID(c.Context(), u.TenantID)
		if err != nil || !tenantEntity.IsActive() {
			continue // Skip inactive or deleted tenants
		}

		option := TenantOption{
			TenantID:    u.TenantID,
			CompanyName: tenantEntity.CompanyName,
			UserStatus:  u.Status,
		}

		// Show available auth methods
		option.AuthMethods.OTP = u.HasOTP()
		option.AuthMethods.OAuth = u.HasOAuth()
		option.AuthMethods.Provider = u.OAuthProvider

		tenantOptions = append(tenantOptions, option)
	}

	return c.JSON(GetUserTenantsResponse{
		Email:   req.Email,
		Tenants: tenantOptions,
		Count:   len(tenantOptions),
	})
}

// ============================================================================
// SIGNUP FLOW
// ============================================================================

// InitiateSignupRequest starts the signup process
type InitiateSignupRequest struct {
	Email           string `json:"email" validate:"required,email"`
	Name            string `json:"name" validate:"required,min=2"`
	InvitationToken string `json:"invitation_token" validate:"required"`
}

type InitiateSignupResponse struct {
	Message       string          `json:"message"`
	Email         string          `json:"email"`
	TenantID      kernel.TenantID `json:"tenant_id"`
	RequiresOTP   bool            `json:"requires_otp"`
	ExpiresIn     int             `json:"expires_in_seconds"`
	AccountLinked bool            `json:"account_linked,omitempty"`
	CanLoginWith  *struct {
		OTP      bool              `json:"otp"`
		OAuth    bool              `json:"oauth"`
		Provider iam.OAuthProvider `json:"oauth_provider,omitempty"`
	} `json:"can_login_with,omitempty"`
}

// InitiateSignup creates user account and sends OTP (with account linking support)
func (h *PasswordlessAuthHandlers) InitiateSignup(c *fiber.Ctx) error {
	var req InitiateSignupRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	// 1. Validate invitation token
	inv, err := h.invitationRepo.FindByToken(c.Context(), req.InvitationToken)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid or expired invitation",
		})
	}

	// 2. Verify invitation is valid
	if !inv.CanBeAccepted() {
		if inv.IsExpired() {
			return c.Status(fiber.StatusGone).JSON(fiber.Map{
				"error": "Invitation has expired",
			})
		}
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invitation cannot be accepted",
		})
	}

	// 3. Verify email matches invitation
	if inv.Email != req.Email {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Email does not match invitation",
		})
	}

	tenantID := inv.TenantID

	// 4. Check if tenant is active
	tenantEntity, err := h.tenantRepo.FindByID(c.Context(), tenantID)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": "Tenant not found",
		})
	}
	if !tenantEntity.IsActive() {
		return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
			"error": "Tenant is not active",
		})
	}

	// 5. Check if user already exists in this tenant
	existingUser, _ := h.userRepo.FindByEmail(c.Context(), req.Email, tenantID)

	// 🔥 ACCOUNT LINKING: Handle existing user
	if existingUser != nil {
		// User exists - check if we can link OTP authentication
		if existingUser.HasOTP() {
			// Already has OTP enabled
			return c.Status(fiber.StatusConflict).JSON(fiber.Map{
				"error":                "Account already exists with email/OTP login. Please use login instead.",
				"can_login_with_otp":   true,
				"can_login_with_oauth": existingUser.HasOAuth(),
				"oauth_provider":       existingUser.OAuthProvider,
			})
		}

		// User exists with OAuth only - enable OTP for them
		if existingUser.HasOAuth() {
			existingUser.EnableOTP()

			// Update user to enable OTP
			if err := h.userRepo.Save(c.Context(), *existingUser); err != nil {
				return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
					"error": "Failed to link OTP to existing account",
				})
			}

			// Generate and send OTP
			otpEntity, err := h.otpService.GenerateOTP(c.Context(), req.Email, otp.OTPPurposeVerification)
			if err != nil {
				return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
					"error": "Failed to send verification code",
				})
			}

			authMethods := struct {
				OTP      bool              `json:"otp"`
				OAuth    bool              `json:"oauth"`
				Provider iam.OAuthProvider `json:"oauth_provider,omitempty"`
			}{
				OTP:      true,
				OAuth:    true,
				Provider: existingUser.OAuthProvider,
			}

			return c.Status(fiber.StatusOK).JSON(InitiateSignupResponse{
				Message:       "OTP authentication linked to your existing account. Please verify your email.",
				Email:         req.Email,
				TenantID:      tenantID,
				RequiresOTP:   true,
				ExpiresIn:     int(time.Until(otpEntity.ExpiresAt).Seconds()),
				AccountLinked: true,
				CanLoginWith:  &authMethods,
			})
		}
	}

	// 6. Check if tenant can add more users (only for new users)
	if existingUser == nil && !tenantEntity.CanAddUser() {
		return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
			"error": "Organization has reached maximum user limit",
		})
	}

	// 7. Create NEW user account
	newUser := &user.User{
		ID:            kernel.NewUserID(uuid.NewString()),
		TenantID:      tenantID,
		Email:         req.Email,
		Name:          req.Name,
		Status:        user.UserStatusPending,
		Scopes:        inv.GetScopes(),
		OTPEnabled:    true, // 🔥 Enable OTP for this user
		EmailVerified: false,
		CreatedAt:     time.Now(),
		UpdatedAt:     time.Now(),
	}

	// 8. Save user
	if err := h.userRepo.Save(c.Context(), *newUser); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to create user account",
		})
	}

	// 9. Update tenant user count
	if err := tenantEntity.AddUser(); err == nil {
		h.tenantRepo.Save(c.Context(), *tenantEntity)
	}

	// 10. Mark invitation as accepted
	if err := inv.Accept(newUser.ID); err == nil {
		h.invitationRepo.Save(c.Context(), *inv)
	}

	// 11. Generate and send OTP
	otpEntity, err := h.otpService.GenerateOTP(c.Context(), req.Email, otp.OTPPurposeVerification)
	if err != nil {
		return c.Status(fiber.StatusPartialContent).JSON(fiber.Map{
			"error":     "Account created but failed to send verification code",
			"message":   "Please request a new code using the resend option",
			"tenant_id": tenantID,
		})
	}

	// 12. Return success response
	return c.Status(fiber.StatusCreated).JSON(InitiateSignupResponse{
		Message:     "Account created! Please check your email for verification code.",
		Email:       req.Email,
		TenantID:    tenantID,
		RequiresOTP: true,
		ExpiresIn:   int(time.Until(otpEntity.ExpiresAt).Seconds()),
	})
}

// VerifySignupRequest completes signup by verifying OTP
type VerifySignupRequest struct {
	Email    string          `json:"email" validate:"required,email"`
	Code     string          `json:"code" validate:"required"`
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
}

// VerifySignup verifies OTP and activates account
func (h *PasswordlessAuthHandlers) VerifySignup(c *fiber.Ctx) error {
	var req VerifySignupRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	// 1. Verify OTP
	_, err := h.otpService.VerifyOTP(c.Context(), req.Email, req.Code)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// 2. Find user
	userEntity, err := h.userRepo.FindByEmail(c.Context(), req.Email, req.TenantID)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": "User not found",
		})
	}

	// 3. Activate user if pending
	if userEntity.Status == user.UserStatusPending {
		if err := userEntity.Activate(); err != nil {
			return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
				"error": err.Error(),
			})
		}
	}

	userEntity.EmailVerified = true
	userEntity.UpdatedAt = time.Now()

	// 4. Save updated user
	if err := h.userRepo.Save(c.Context(), *userEntity); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to activate account",
		})
	}

	return c.JSON(fiber.Map{
		"message":   "Email verified! Your account is now active. You can log in.",
		"tenant_id": req.TenantID,
		"email":     req.Email,
	})
}

// ============================================================================
// LOGIN FLOW
// ============================================================================

// InitiateLoginRequest starts the login process
type InitiateLoginRequest struct {
	Email    string          `json:"email" validate:"required,email"`
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
}

type InitiateLoginResponse struct {
	Message     string `json:"message"`
	Email       string `json:"email"`
	ExpiresIn   int    `json:"expires_in_seconds"`
	AuthMethods *struct {
		OTP      bool              `json:"otp"`
		OAuth    bool              `json:"oauth"`
		Provider iam.OAuthProvider `json:"oauth_provider,omitempty"`
	} `json:"auth_methods,omitempty"`
}

// InitiateLogin sends OTP for login
func (h *PasswordlessAuthHandlers) InitiateLogin(c *fiber.Ctx) error {
	var req InitiateLoginRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	// 1. Find user by email and tenant
	userEntity, err := h.userRepo.FindByEmail(c.Context(), req.Email, req.TenantID)
	if err != nil {
		// Don't reveal if user exists
		return c.JSON(InitiateLoginResponse{
			Message:   "If this email is registered, you'll receive a login code.",
			Email:     req.Email,
			ExpiresIn: 300,
		})
	}

	// 2. Check if user is active
	if !userEntity.IsActive() {
		return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
			"error": "Account is not active. Please complete signup verification or contact support.",
		})
	}

	// 🔥 3. Check if OTP is enabled for this user
	if !userEntity.HasOTP() {
		// User signed up with OAuth only - suggest OAuth login
		oauthProvider := "OAuth"
		if userEntity.OAuthProvider == iam.OAuthProviderGoogle {
			oauthProvider = "Google"
		} else if userEntity.OAuthProvider == iam.OAuthProviderMicrosoft {
			oauthProvider = "Microsoft"
		}

		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error":                fmt.Sprintf("This account uses %s login. Please sign in with %s instead.", oauthProvider, oauthProvider),
			"can_login_with_oauth": true,
			"oauth_provider":       userEntity.OAuthProvider,
			"suggestion":           "You can enable email/OTP login by signing up again with your invitation link.",
		})
	}

	// 4. Check if email is verified
	if !userEntity.EmailVerified {
		return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
			"error":                 "Email not verified. Please verify your email first.",
			"requires_verification": true,
		})
	}

	// 5. Check tenant status
	tenantEntity, err := h.tenantRepo.FindByID(c.Context(), userEntity.TenantID)
	if err != nil || !tenantEntity.IsActive() {
		return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
			"error": "Account access is currently unavailable",
		})
	}

	// 6. Generate and send OTP
	otpEntity, err := h.otpService.GenerateOTP(c.Context(), req.Email, otp.OTPPurposeVerification)
	if err != nil {
		return c.Status(fiber.StatusTooManyRequests).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	// 7. Return success response with available auth methods
	authMethods := struct {
		OTP      bool              `json:"otp"`
		OAuth    bool              `json:"oauth"`
		Provider iam.OAuthProvider `json:"oauth_provider,omitempty"`
	}{
		OTP:      true,
		OAuth:    userEntity.HasOAuth(),
		Provider: userEntity.OAuthProvider,
	}

	return c.JSON(InitiateLoginResponse{
		Message:     "Login code sent to your email!",
		Email:       req.Email,
		ExpiresIn:   int(time.Until(otpEntity.ExpiresAt).Seconds()),
		AuthMethods: &authMethods,
	})
}

// VerifyLoginRequest completes login by verifying OTP
type VerifyLoginRequest struct {
	Email    string          `json:"email" validate:"required,email"`
	Code     string          `json:"code" validate:"required"`
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
}

// VerifyLogin verifies OTP and returns JWT tokens
func (h *PasswordlessAuthHandlers) VerifyLogin(c *fiber.Ctx) error {
	var req VerifyLoginRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	// 1. Verify OTP
	_, err := h.otpService.VerifyOTP(c.Context(), req.Email, req.Code)
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "Invalid or expired code",
		})
	}

	// 2. Find user
	userEntity, err := h.userRepo.FindByEmail(c.Context(), req.Email, req.TenantID)
	if err != nil {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "Authentication failed",
		})
	}

	// 3. Check user can login
	if !userEntity.CanLogin() {
		return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
			"error": "Account cannot login. Status: " + string(userEntity.Status),
		})
	}

	// 4. Get tenant
	tenantEntity, err := h.tenantRepo.FindByID(c.Context(), userEntity.TenantID)
	if err != nil || !tenantEntity.IsActive() {
		return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
			"error": "Organization is not active",
		})
	}

	// 5. Ensure email is verified
	if !userEntity.EmailVerified {
		userEntity.EmailVerified = true
		h.userRepo.Save(c.Context(), *userEntity)
	}

	// 6. Generate JWT tokens
	accessToken, err := h.tokenService.GenerateAccessToken(userEntity.ID, tenantEntity.ID, map[string]any{
		"email":  userEntity.Email,
		"name":   userEntity.Name,
		"scopes": userEntity.Scopes,
	})
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to generate access token",
		})
	}

	refreshTokenStr, err := h.tokenService.GenerateRefreshToken(userEntity.ID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "Failed to generate refresh token",
		})
	}

	// 7. Save refresh token
	refreshToken := RefreshToken{
		ID:        uuid.NewString(),
		Token:     refreshTokenStr,
		UserID:    userEntity.ID,
		TenantID:  tenantEntity.ID,
		ExpiresAt: time.Now().Add(h.config.Auth.JWT.RefreshTokenTTL),
		CreatedAt: time.Now(),
		IsRevoked: false,
	}
	h.tokenRepo.SaveRefreshToken(c.Context(), refreshToken)

	// 8. Create session
	session := UserSession{
		ID:           uuid.NewString(),
		UserID:       userEntity.ID,
		TenantID:     tenantEntity.ID,
		SessionToken: uuid.NewString(),
		IPAddress:    c.IP(),
		UserAgent:    c.Get("User-Agent"),
		ExpiresAt:    time.Now().Add(h.config.Auth.JWT.RefreshTokenTTL),
		CreatedAt:    time.Now(),
		LastActivity: time.Now(),
	}
	h.sessionRepo.SaveSession(c.Context(), session)

	// 9. Update last login
	userEntity.UpdateLastLogin()
	h.userRepo.Save(c.Context(), *userEntity)

	// 10. Set cookies
	c.Cookie(&fiber.Cookie{
		Name:     h.config.Auth.Cookie.AccessTokenName,
		Value:    accessToken,
		Expires:  time.Now().Add(h.config.Auth.JWT.AccessTokenTTL),
		HTTPOnly: h.config.Auth.Cookie.HTTPOnly,
		Secure:   h.config.Auth.Cookie.Secure,
		SameSite: h.config.Auth.Cookie.SameSite,
		Domain:   h.config.Auth.Cookie.Domain,
		Path:     h.config.Auth.Cookie.Path,
	})

	c.Cookie(&fiber.Cookie{
		Name:     h.config.Auth.Cookie.RefreshTokenName,
		Value:    refreshTokenStr,
		Expires:  time.Now().Add(h.config.Auth.JWT.RefreshTokenTTL),
		HTTPOnly: h.config.Auth.Cookie.HTTPOnly,
		Secure:   h.config.Auth.Cookie.Secure,
		SameSite: h.config.Auth.Cookie.SameSite,
		Domain:   h.config.Auth.Cookie.Domain,
		Path:     h.config.Auth.Cookie.Path,
	})

	// 11. Return tokens and user info
	return c.JSON(TokenResponse{
		AccessToken:  accessToken,
		RefreshToken: refreshTokenStr,
		TokenType:    "Bearer",
		ExpiresIn:    int(h.config.Auth.JWT.AccessTokenTTL / time.Second),
		User:         userEntity.ToDTO(),
		Tenant:       tenantEntity.ToDTO(),
	})
}

// ============================================================================
// UTILITY
// ============================================================================

// ResendOTPRequest for resending OTP
type ResendOTPRequest struct {
	Email    string          `json:"email" validate:"required,email"`
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Purpose  string          `json:"purpose" validate:"required,oneof=signup login"`
}

// ResendOTP resends OTP code
func (h *PasswordlessAuthHandlers) ResendOTP(c *fiber.Ctx) error {
	var req ResendOTPRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	// Verify user exists in the tenant
	userEntity, err := h.userRepo.FindByEmail(c.Context(), req.Email, req.TenantID)
	if err != nil {
		// Don't reveal if user exists
		return c.JSON(fiber.Map{
			"message":    "If this email is registered, a verification code has been sent",
			"expires_in": 300,
		})
	}

	// Check tenant is active
	tenantEntity, err := h.tenantRepo.FindByID(c.Context(), req.TenantID)
	if err != nil || !tenantEntity.IsActive() {
		return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
			"error": "Unable to send verification code",
		})
	}

	// Check user status based on purpose
	if req.Purpose == "signup" && userEntity.Status != user.UserStatusPending {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Account is already verified. Please use login instead.",
		})
	}

	if req.Purpose == "login" && !userEntity.IsActive() {
		return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
			"error": "Account is not active",
		})
	}

	// Generate new OTP
	otpEntity, err := h.otpService.GenerateOTP(c.Context(), req.Email, otp.OTPPurposeVerification)
	if err != nil {
		return c.Status(fiber.StatusTooManyRequests).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	return c.JSON(fiber.Map{
		"message":    "Verification code sent",
		"expires_in": int(time.Until(otpEntity.ExpiresAt).Seconds()),
	})
}
package auth

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strings"

	"github.com/Abraxas-365/manifesto/pkg/config"
	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam"
)

const (
	GoogleAuthURL     = "https://accounts.google.com/o/oauth2/auth"
	GoogleTokenURL    = "https://oauth2.googleapis.com/token"
	GoogleUserInfoURL = "https://www.googleapis.com/oauth2/v2/userinfo"
)

// Update struct to include URLs
type GoogleOAuthService struct {
	config       OAuthConfig
	httpClient   *http.Client
	stateManager StateManager
	authURL      string
	tokenURL     string
	userInfoURL  string
}

// GoogleOAuthService implementación del servicio OAuth para Google
func NewGoogleOAuthServiceFromConfig(cfg *config.OAuthProviderConfig, stateManager StateManager) *GoogleOAuthService {
	return &GoogleOAuthService{
		config: OAuthConfig{
			ClientID:     cfg.ClientID,
			ClientSecret: cfg.ClientSecret,
			RedirectURL:  cfg.RedirectURL,
			Scopes:       cfg.Scopes,
		},
		httpClient:   &http.Client{Timeout: cfg.Timeout},
		stateManager: stateManager,
		authURL:      cfg.AuthURL,
		tokenURL:     cfg.TokenURL,
		userInfoURL:  cfg.UserInfoURL,
	}
}

// GetProvider retorna el proveedor OAuth
func (g *GoogleOAuthService) GetProvider() iam.OAuthProvider {
	return iam.OAuthProviderGoogle
}

// GetAuthURL genera la URL de autorización de Google
func (g *GoogleOAuthService) GetAuthURL(state string) string {
	params := url.Values{
		"client_id":     {g.config.ClientID},
		"redirect_uri":  {g.config.RedirectURL},
		"scope":         {strings.Join(g.config.Scopes, " ")},
		"response_type": {"code"},
		"state":         {state},
		"access_type":   {"offline"}, // Para obtener refresh token
		"prompt":        {"consent"}, // Forzar consent para obtener refresh token
	}

	return fmt.Sprintf("%s?%s", GoogleAuthURL, params.Encode())
}

// ValidateState valida el estado OAuth
func (g *GoogleOAuthService) ValidateState(state string) bool {
	return g.stateManager.ValidateState(state)
}

// ExchangeToken intercambia el código de autorización por tokens
func (g *GoogleOAuthService) ExchangeToken(ctx context.Context, code string) (*OAuthTokenResponse, error) {
	data := url.Values{
		"client_id":     {g.config.ClientID},
		"client_secret": {g.config.ClientSecret},
		"code":          {code},
		"grant_type":    {"authorization_code"},
		"redirect_uri":  {g.config.RedirectURL},
	}

	req, err := http.NewRequestWithContext(ctx, "POST", GoogleTokenURL, strings.NewReader(data.Encode()))
	if err != nil {
		return nil, errx.Wrap(err, "failed to create token request", errx.TypeInternal)
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	resp, err := g.httpClient.Do(req)
	if err != nil {
		return nil, errx.Wrap(err, "failed to exchange token", errx.TypeExternal)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, ErrOAuthAuthorizationFailed().
			WithDetail("status_code", resp.StatusCode).
			WithDetail("provider", "google")
	}

	var tokenResp OAuthTokenResponse
	if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
		return nil, errx.Wrap(err, "failed to decode token response", errx.TypeExternal)
	}

	return &tokenResp, nil
}

// GetUserInfo obtiene la información del usuario desde Google
func (g *GoogleOAuthService) GetUserInfo(ctx context.Context, accessToken string) (*OAuthUserInfo, error) {
	req, err := http.NewRequestWithContext(ctx, "GET", GoogleUserInfoURL, nil)
	if err != nil {
		return nil, errx.Wrap(err, "failed to create user info request", errx.TypeInternal)
	}

	req.Header.Set("Authorization", "Bearer "+accessToken)

	resp, err := g.httpClient.Do(req)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get user info", errx.TypeExternal)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, ErrOAuthAuthorizationFailed().
			WithDetail("status_code", resp.StatusCode).
			WithDetail("provider", "google").
			WithDetail("endpoint", "userinfo")
	}

	var googleUser struct {
		ID            string `json:"id"`
		Email         string `json:"email"`
		Name          string `json:"name"`
		Picture       string `json:"picture"`
		EmailVerified bool   `json:"verified_email"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&googleUser); err != nil {
		return nil, errx.Wrap(err, "failed to decode user info", errx.TypeExternal)
	}

	return &OAuthUserInfo{
		ID:            googleUser.ID,
		Email:         googleUser.Email,
		Name:          googleUser.Name,
		Picture:       googleUser.Picture,
		EmailVerified: googleUser.EmailVerified,
	}, nil
}
package otp

import (
	"github.com/Abraxas-365/manifesto/pkg/errx"
	"net/http"
)

var ErrRegistry = errx.NewRegistry("OTP")

var (
	CodeInvalidOTP      = ErrRegistry.Register("INVALID_OTP", errx.TypeValidation, http.StatusBadRequest, "Invalid or incorrect OTP code")
	CodeOTPExpired      = ErrRegistry.Register("OTP_EXPIRED", errx.TypeValidation, http.StatusBadRequest, "OTP code has expired")
	CodeOTPAlreadyUsed  = ErrRegistry.Register("OTP_ALREADY_USED", errx.TypeBusiness, http.StatusBadRequest, "OTP code has already been used")
	CodeTooManyAttempts = ErrRegistry.Register("TOO_MANY_ATTEMPTS", errx.TypeBusiness, http.StatusTooManyRequests, "Too many verification attempts")
	CodeTooManyRequests = ErrRegistry.Register("TOO_MANY_REQUESTS", errx.TypeBusiness, http.StatusTooManyRequests, "Too many OTP requests")
)

func ErrInvalidOTP() *errx.Error      { return ErrRegistry.New(CodeInvalidOTP) }
func ErrOTPExpired() *errx.Error      { return ErrRegistry.New(CodeOTPExpired) }
func ErrOTPAlreadyUsed() *errx.Error  { return ErrRegistry.New(CodeOTPAlreadyUsed) }
func ErrTooManyAttempts() *errx.Error { return ErrRegistry.New(CodeTooManyAttempts) }
func ErrTooManyRequests() *errx.Error { return ErrRegistry.New(CodeTooManyRequests) }
package otp

import "context"

type Repository interface {
	Create(ctx context.Context, otp *OTP) error
	GetByContactAndCode(ctx context.Context, contact string, code string) (*OTP, error)
	GetLatestByContact(ctx context.Context, contact string, purpose OTPPurpose) (*OTP, error)
	Update(ctx context.Context, otp *OTP) error
	DeleteExpired(ctx context.Context) error
}
package otp

import (
	"crypto/rand"
	"fmt"
	"math/big"
	"time"
)

type OTPPurpose string

const (
	OTPPurposeJobApplication OTPPurpose = "JOB_APPLICATION"
	OTPPurposeVerification   OTPPurpose = "VERIFICATION"
)

type OTP struct {
	ID          string
	Contact     string // Email or phone
	Code        string
	Purpose     OTPPurpose
	ExpiresAt   time.Time
	VerifiedAt  *time.Time
	Attempts    int
	CreatedAt   time.Time
	MaxAttempts int
}

func (o *OTP) IsValid() bool {
	return time.Now().Before(o.ExpiresAt) && o.VerifiedAt == nil && o.Attempts < o.MaxAttempts
}

func (o *OTP) IsExpired() bool {
	return time.Now().After(o.ExpiresAt)
}

func (o *OTP) Verify() error {
	if o.Attempts >= o.MaxAttempts {
		return ErrTooManyAttempts()
	}
	if o.IsExpired() {
		return ErrOTPExpired()
	}
	if o.Attempts >= 5 {
		return ErrTooManyAttempts()
	}
	now := time.Now()
	o.VerifiedAt = &now
	return nil
}

func (o *OTP) IncrementAttempts() {
	o.Attempts++
}

// GenerateOTPCode generates a cryptographically secure random OTP code
func GenerateOTPCode(length int) (string, error) {
	// Calculate max value (10^length - 1)
	max := new(big.Int)
	max.Exp(big.NewInt(10), big.NewInt(int64(length)), nil)

	// Generate random number between 0 and max-1
	n, err := rand.Int(rand.Reader, max)
	if err != nil {
		return "", err
	}

	// Format with leading zeros
	format := fmt.Sprintf("%%0%dd", length)
	return fmt.Sprintf(format, n), nil
}
// pkg/iam/otp/otpsrv/service.go

package otpsrv

import (
	"context"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/config"
	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam/otp"
	"github.com/google/uuid"
)

// NotificationService is a generic interface for sending OTP codes
type NotificationService interface {
	SendOTP(ctx context.Context, contact string, code string) error
}

type OTPService struct {
	repo                otp.Repository
	notificationService NotificationService
	config              *config.OTPConfig
}

func NewOTPService(
	repo otp.Repository,
	notificationService NotificationService,
	cfg *config.OTPConfig,
) *OTPService {
	return &OTPService{
		repo:                repo,
		notificationService: notificationService,
		config:              cfg,
	}
}

// GenerateOTP creates and sends an OTP
func (s *OTPService) GenerateOTP(ctx context.Context, contact string, purpose otp.OTPPurpose) (*otp.OTP, error) {
	// Rate limiting check
	existing, _ := s.repo.GetLatestByContact(ctx, contact, purpose)
	if existing != nil && existing.IsValid() {
		timeSinceCreation := time.Since(existing.CreatedAt)
		if timeSinceCreation < s.config.RateLimitWindow {
			return nil, otp.ErrTooManyRequests().WithDetail(
				"retry_after",
				s.config.RateLimitWindow.String(),
			)
		}
	}

	// Generate code with configurable length
	code, err := otp.GenerateOTPCode(s.config.CodeLength)
	if err != nil {
		return nil, errx.Wrap(err, "failed to generate OTP code", errx.TypeInternal)
	}

	// Create OTP
	newOTP := &otp.OTP{
		ID:          uuid.NewString(),
		Contact:     contact,
		Code:        code,
		Purpose:     purpose,
		ExpiresAt:   time.Now().Add(s.config.ExpirationTime),
		Attempts:    0,
		MaxAttempts: s.config.MaxAttempts,
		CreatedAt:   time.Now(),
	}

	// Save OTP
	if err := s.repo.Create(ctx, newOTP); err != nil {
		return nil, errx.Wrap(err, "failed to save OTP", errx.TypeInternal)
	}

	// Send notification
	if err := s.notificationService.SendOTP(ctx, contact, code); err != nil {
		return nil, errx.Wrap(err, "failed to send OTP", errx.TypeExternal)
	}

	return newOTP, nil
}

// VerifyOTP validates an OTP code
func (s *OTPService) VerifyOTP(ctx context.Context, contact string, code string) (*otp.OTP, error) {
	otpEntity, err := s.repo.GetByContactAndCode(ctx, contact, code)
	if err != nil {
		return nil, otp.ErrInvalidOTP()
	}

	if otpEntity.IsExpired() {
		return nil, otp.ErrOTPExpired()
	}

	if otpEntity.Attempts >= otpEntity.MaxAttempts {
		return nil, otp.ErrTooManyAttempts()
	}

	if otpEntity.VerifiedAt != nil {
		return nil, otp.ErrOTPAlreadyUsed()
	}

	otpEntity.IncrementAttempts()

	if otpEntity.Code == code {
		if err := otpEntity.Verify(); err != nil {
			return nil, err
		}

		if err := s.repo.Update(ctx, otpEntity); err != nil {
			return nil, errx.Wrap(err, "failed to update OTP", errx.TypeInternal)
		}

		return otpEntity, nil
	}

	if err := s.repo.Update(ctx, otpEntity); err != nil {
		return nil, errx.Wrap(err, "failed to update OTP attempts", errx.TypeInternal)
	}

	remainingAttempts := otpEntity.MaxAttempts - otpEntity.Attempts
	return nil, otp.ErrInvalidOTP().WithDetail("attempts_remaining", remainingAttempts)
}

package otpinfra

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam/otp"
	"github.com/jmoiron/sqlx"
)

type PostgresOTPRepository struct {
	db *sqlx.DB
}

func NewPostgresOTPRepository(db *sqlx.DB) *PostgresOTPRepository {
	return &PostgresOTPRepository{db: db}
}

// Create inserts a new OTP into the database
func (r *PostgresOTPRepository) Create(ctx context.Context, o *otp.OTP) error {
	query := `
        INSERT INTO otps (id, contact, code, purpose, expires_at, attempts, max_attempts, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    `

	_, err := r.db.ExecContext(
		ctx,
		query,
		o.ID,
		o.Contact,
		o.Code,
		string(o.Purpose),
		o.ExpiresAt,
		o.Attempts,
		o.MaxAttempts, // ✅ Added
		o.CreatedAt,
		time.Now(),
	)

	if err != nil {
		return errx.Wrap(err, "failed to create OTP", errx.TypeInternal)
	}

	return nil
}

// GetByContactAndCode retrieves an OTP by contact and code
func (r *PostgresOTPRepository) GetByContactAndCode(ctx context.Context, contact string, code string) (*otp.OTP, error) {
	query := `
        SELECT id, contact, code, purpose, expires_at, verified_at, attempts, max_attempts, created_at
        FROM otps
        WHERE contact = $1 AND code = $2
        ORDER BY created_at DESC
        LIMIT 1
    `

	// 🔍 DEBUG
	fmt.Printf("🔍 DEBUG GetByContactAndCode:\n")
	fmt.Printf("   Contact: '%s' (len=%d)\n", contact, len(contact))
	fmt.Printf("   Code: '%s' (len=%d)\n", code, len(code))

	var o otp.OTP
	var verifiedAt sql.NullTime
	var purposeStr string

	err := r.db.QueryRowContext(ctx, query, contact, code).Scan(
		&o.ID,
		&o.Contact,
		&o.Code,
		&purposeStr,
		&o.ExpiresAt,
		&verifiedAt,
		&o.Attempts,
		&o.MaxAttempts, // ✅ Added
		&o.CreatedAt,
	)

	if err == sql.ErrNoRows {
		fmt.Printf("   ❌ No OTP found in database\n")
		return nil, otp.ErrInvalidOTP()
	}
	if err != nil {
		fmt.Printf("   ❌ Query error: %v\n", err)
		return nil, errx.Wrap(err, "failed to get OTP", errx.TypeInternal)
	}

	fmt.Printf("   ✅ OTP found:\n")
	fmt.Printf("      ID: %s\n", o.ID)
	fmt.Printf("      Code: '%s' (len=%d)\n", o.Code, len(o.Code))
	fmt.Printf("      Contact: '%s'\n", o.Contact)
	fmt.Printf("      MaxAttempts: %d\n", o.MaxAttempts)
	fmt.Printf("      Attempts: %d\n", o.Attempts)
	fmt.Printf("      ExpiresAt: %s\n", o.ExpiresAt)
	fmt.Printf("      VerifiedAt: %v\n", verifiedAt)

	o.Purpose = otp.OTPPurpose(purposeStr)
	if verifiedAt.Valid {
		o.VerifiedAt = &verifiedAt.Time
	}

	return &o, nil
}

// GetLatestByContact retrieves the most recent OTP for a contact and purpose
func (r *PostgresOTPRepository) GetLatestByContact(ctx context.Context, contact string, purpose otp.OTPPurpose) (*otp.OTP, error) {
	query := `
        SELECT id, contact, code, purpose, expires_at, verified_at, attempts, max_attempts, created_at
        FROM otps
        WHERE contact = $1 AND purpose = $2
        ORDER BY created_at DESC
        LIMIT 1
    `

	var o otp.OTP
	var verifiedAt sql.NullTime
	var purposeStr string

	err := r.db.QueryRowContext(ctx, query, contact, string(purpose)).Scan(
		&o.ID,
		&o.Contact,
		&o.Code,
		&purposeStr,
		&o.ExpiresAt,
		&verifiedAt,
		&o.Attempts,
		&o.MaxAttempts, // ✅ Added
		&o.CreatedAt,
	)

	if err == sql.ErrNoRows {
		return nil, nil // No OTP found is not an error in this case
	}
	if err != nil {
		return nil, errx.Wrap(err, "failed to get latest OTP", errx.TypeInternal)
	}

	o.Purpose = otp.OTPPurpose(purposeStr)
	if verifiedAt.Valid {
		o.VerifiedAt = &verifiedAt.Time
	}

	return &o, nil
}

// Update updates an existing OTP
func (r *PostgresOTPRepository) Update(ctx context.Context, o *otp.OTP) error {
	query := `
        UPDATE otps
        SET verified_at = $1, attempts = $2, updated_at = $3
        WHERE id = $4
    `

	var verifiedAt interface{}
	if o.VerifiedAt != nil {
		verifiedAt = *o.VerifiedAt
	}

	result, err := r.db.ExecContext(
		ctx,
		query,
		verifiedAt,
		o.Attempts,
		time.Now(),
		o.ID,
	)

	if err != nil {
		return errx.Wrap(err, "failed to update OTP", errx.TypeInternal)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rows == 0 {
		return errx.New("OTP not found", errx.TypeNotFound)
	}

	return nil
}

// DeleteExpired removes all expired OTPs from the database
func (r *PostgresOTPRepository) DeleteExpired(ctx context.Context) error {
	query := `
        DELETE FROM otps
        WHERE expires_at < $1
    `

	_, err := r.db.ExecContext(ctx, query, time.Now())
	if err != nil {
		return errx.Wrap(err, "failed to delete expired OTPs", errx.TypeInternal)
	}

	return nil
}
package user

import (
	"net/http"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/Abraxas-365/manifesto/pkg/ptrx"
	"slices"
)

// ============================================================================
// User Entity
// ============================================================================

// UserStatus define los posibles estados de un usuario
type UserStatus string

const (
	UserStatusActive    UserStatus = "ACTIVE"
	UserStatusInactive  UserStatus = "INACTIVE"
	UserStatusSuspended UserStatus = "SUSPENDED"
	UserStatusPending   UserStatus = "PENDING" // Invitado pero no completó onboarding
)

// User es la entidad rica que representa a un usuario en el sistema
// User entity
type User struct {
	ID       kernel.UserID   `db:"id" json:"id"`
	TenantID kernel.TenantID `db:"tenant_id" json:"tenant_id"`
	Email    string          `db:"email" json:"email"`
	Name     string          `db:"name" json:"name"`
	Picture  *string         `db:"picture" json:"picture,omitempty"`

	// Authentication methods (can have multiple)
	OAuthProvider   iam.OAuthProvider `db:"oauth_provider" json:"oauth_provider"`
	OAuthProviderID string            `db:"oauth_provider_id" json:"oauth_provider_id"`
	OTPEnabled      bool              `db:"otp_enabled" json:"otp_enabled"` // NEW: Track if OTP is enabled

	Status        UserStatus `db:"status" json:"status"`
	Scopes        []string   `db:"scopes" json:"scopes"`
	EmailVerified bool       `db:"email_verified" json:"email_verified"`
	LastLoginAt   *time.Time `db:"last_login_at" json:"last_login_at,omitempty"`
	CreatedAt     time.Time  `db:"created_at" json:"created_at"`
	UpdatedAt     time.Time  `db:"updated_at" json:"updated_at"`
}

// Domain methods
func (u *User) HasOAuth() bool {
	return u.OAuthProvider != "" && u.OAuthProviderID != ""
}

func (u *User) HasOTP() bool {
	return u.OTPEnabled
}

func (u *User) HasMultipleAuthMethods() bool {
	return u.HasOAuth() && u.HasOTP()
}

func (u *User) CanLoginWithOAuth() bool {
	return u.HasOAuth() && u.IsActive()
}

func (u *User) CanLoginWithOTP() bool {
	return u.HasOTP() && u.IsActive() && u.EmailVerified
}

func (u *User) EnableOTP() {
	u.OTPEnabled = true
	u.UpdatedAt = time.Now()
}

func (u *User) LinkOAuth(provider iam.OAuthProvider, providerID string) {
	u.OAuthProvider = provider
	u.OAuthProviderID = providerID
	u.UpdatedAt = time.Now()
}

// ============================================================================
// Domain Methods
// ============================================================================

// IsActive verifica si el usuario está activo
func (u *User) IsActive() bool {
	return u.Status == UserStatusActive
}

// CanLogin verifica si el usuario puede iniciar sesión
func (u *User) CanLogin() bool {
	return u.IsActive() && u.EmailVerified
}

// Activate activa un usuario pendiente
func (u *User) Activate() error {
	if u.Status != UserStatusPending {
		return ErrInvalidStatus().WithDetail("current_status", u.Status)
	}

	u.Status = UserStatusActive
	u.UpdatedAt = time.Now()
	return nil
}

// Suspend suspende un usuario activo
func (u *User) Suspend(reason string) error {
	if !u.IsActive() {
		return ErrInvalidStatus().WithDetail("current_status", u.Status)
	}

	u.Status = UserStatusSuspended
	u.UpdatedAt = time.Now()
	return nil
}

// UpdateLastLogin actualiza la fecha del último login
func (u *User) UpdateLastLogin() {
	now := time.Now()
	u.LastLoginAt = &now
	u.UpdatedAt = now
}

// UpdateProfile actualiza la información del perfil
func (u *User) UpdateProfile(name, picture string) {
	if name != "" {
		u.Name = name
	}
	if picture != "" {
		u.Picture = ptrx.String(picture)
	}
	u.UpdatedAt = time.Now()
}

// ============================================================================
// Scope Management Methods
// ============================================================================

// HasScope verifica si el usuario tiene un scope específico
func (u *User) HasScope(scope string) bool {
	for _, s := range u.Scopes {
		// Exact match or wildcard "*"
		if s == scope || s == "*" {
			return true
		}
		// Wildcard match (e.g., "channels:*" matches "channels:read")
		if len(s) > 2 && s[len(s)-2:] == ":*" {
			prefix := s[:len(s)-2]
			if len(scope) > len(prefix) && scope[:len(prefix)] == prefix && scope[len(prefix)] == ':' {
				return true
			}
		}
	}
	return false
}

// IsAdmin verifica si el usuario tiene permisos de administrador
func (u *User) IsAdmin() bool {
	return u.HasScope("*") || u.HasScope("admin:*")
}

// HasAnyScope verifica si el usuario tiene alguno de los scopes proporcionados
func (u *User) HasAnyScope(scopes ...string) bool {
	return slices.ContainsFunc(scopes, u.HasScope)
}

// HasAllScopes verifica si el usuario tiene todos los scopes proporcionados
func (u *User) HasAllScopes(scopes ...string) bool {
	for _, scope := range scopes {
		if !u.HasScope(scope) {
			return false
		}
	}
	return true
}

// AddScope agrega un scope al usuario
func (u *User) AddScope(scope string) {
	if !u.HasScope(scope) {
		u.Scopes = append(u.Scopes, scope)
		u.UpdatedAt = time.Now()
	}
}

// RemoveScope remueve un scope del usuario
func (u *User) RemoveScope(scope string) {
	var newScopes []string
	for _, s := range u.Scopes {
		if s != scope {
			newScopes = append(newScopes, s)
		}
	}
	u.Scopes = newScopes
	u.UpdatedAt = time.Now()
}

// SetScopes establece los scopes del usuario
func (u *User) SetScopes(scopes []string) {
	u.Scopes = scopes
	u.UpdatedAt = time.Now()
}

// MakeAdmin convierte al usuario en administrador (asigna scope "*")
func (u *User) MakeAdmin() {
	u.AddScope("*")
}

// RevokeAdmin remueve permisos de administrador
func (u *User) RevokeAdmin() {
	u.RemoveScope("*")
	u.RemoveScope("admin:*")
}

// ============================================================================
// DTOs
// ============================================================================

// UserDetailsDTO contiene información básica de un usuario para otros módulos
type UserDetailsDTO struct {
	ID            kernel.UserID     `json:"id"`
	TenantID      kernel.TenantID   `json:"tenant_id"`
	Name          string            `json:"name"`
	Email         string            `json:"email"`
	Picture       *string           `json:"picture,omitempty"`
	IsActive      bool              `json:"is_active"`
	Scopes        []string          `json:"scopes"`
	OAuthProvider iam.OAuthProvider `json:"oauth_provider"`
}

// ToDTO convierte la entidad User a UserDetailsDTO
func (u *User) ToDTO() UserDetailsDTO {
	return UserDetailsDTO{
		ID:            u.ID,
		TenantID:      u.TenantID,
		Name:          u.Name,
		Email:         u.Email,
		Picture:       u.Picture,
		IsActive:      u.IsActive(),
		Scopes:        u.Scopes,
		OAuthProvider: u.OAuthProvider,
	}
}

// ============================================================================
// Service DTOs - Para operaciones de la capa de servicio
// ============================================================================

// CreateUserRequest representa la petición para crear un usuario
type CreateUserRequest struct {
	TenantID      kernel.TenantID `json:"tenant_id" validate:"required"`
	Email         string          `json:"email" validate:"required,email"`
	Name          string          `json:"name" validate:"required,min=2"`
	Scopes        []string        `json:"scopes,omitempty"`         // ✅ Direct scopes
	ScopeTemplate *string         `json:"scope_template,omitempty"` // ✅ Template name (e.g., "recruiter", "hiring_manager")
}

// UpdateUserRequest representa la petición para actualizar un usuario
type UpdateUserRequest struct {
	TenantID      kernel.TenantID `json:"tenant_id" validate:"required"`
	Name          *string         `json:"name,omitempty" validate:"omitempty,min=2"`
	Status        *UserStatus     `json:"status,omitempty"`
	Scopes        []string        `json:"scopes,omitempty"`         // ✅ Direct scopes to set
	ScopeTemplate *string         `json:"scope_template,omitempty"` // ✅ Template to apply
}

// InviteUserRequest para invitar usuarios a un tenant
type InviteUserRequest struct {
	Email         string   `json:"email" validate:"required,email"`
	Scopes        []string `json:"scopes,omitempty"`
	ScopeTemplate *string  `json:"scope_template,omitempty"`
}

// UserResponse representa la respuesta completa de un usuario
type UserResponse struct {
	User User `json:"user"`
}

// ToDTO convierte UserResponse a UserResponseDTO
func (ur *UserResponse) ToDTO() UserResponseDTO {
	return UserResponseDTO{
		User: ur.User.ToDTO(),
	}
}

// UserResponseDTO es la versión DTO de UserResponse
type UserResponseDTO struct {
	User UserDetailsDTO `json:"user"`
}

// SuspendUserRequest para suspender un usuario
type SuspendUserRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Reason   string          `json:"reason" validate:"required,min=5"`
}

// ActivateUserRequest para activar un usuario
type ActivateUserRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
}

// UserListResponse para listas de usuarios
type UserListResponse struct {
	Users []UserResponse `json:"users"`
	Total int            `json:"total"`
}

// ToDTO convierte UserListResponse a UserListResponseDTO
func (ulr *UserListResponse) ToDTO() UserListResponseDTO {
	var usersDTO []UserResponseDTO
	for _, u := range ulr.Users {
		usersDTO = append(usersDTO, u.ToDTO())
	}

	return UserListResponseDTO{
		Users: usersDTO,
		Total: ulr.Total,
	}
}

// UserListResponseDTO es la versión DTO de UserListResponse
type UserListResponseDTO struct {
	Users []UserResponseDTO `json:"users"`
	Total int               `json:"total"`
}

// ============================================================================
// Scope Management DTOs
// ============================================================================

// ScopeDetail información detallada de un scope
type ScopeDetail struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	Category    string `json:"category"`
}

// AddScopesRequest para agregar scopes a un usuario
type AddScopesRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Scopes   []string        `json:"scopes" validate:"required,min=1"`
}

// RemoveScopesRequest para remover scopes de un usuario
type RemoveScopesRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Scopes   []string        `json:"scopes" validate:"required,min=1"`
}

// SetScopesRequest para establecer scopes de un usuario
type SetScopesRequest struct {
	TenantID kernel.TenantID `json:"tenant_id" validate:"required"`
	Scopes   []string        `json:"scopes" validate:"required,min=1"`
}

// ApplyScopeTemplateRequest para aplicar una plantilla de scopes
type ApplyScopeTemplateRequest struct {
	TenantID     kernel.TenantID `json:"tenant_id" validate:"required"`
	TemplateName string          `json:"template_name" validate:"required"`
}

// UserScopesResponse respuesta con los scopes de un usuario
type UserScopesResponse struct {
	UserID       kernel.UserID `json:"user_id"`
	Scopes       []string      `json:"scopes"`
	ScopeDetails []ScopeDetail `json:"scope_details"`
	TotalScopes  int           `json:"total_scopes"`
	IsAdmin      bool          `json:"is_admin"`
}

// ScopeTemplateResponse respuesta con detalles de una plantilla
type ScopeTemplateResponse struct {
	TemplateName string        `json:"template_name"`
	Description  string        `json:"description,omitempty"`
	Scopes       []string      `json:"scopes"`
	ScopeDetails []ScopeDetail `json:"scope_details"`
	TotalScopes  int           `json:"total_scopes"`
}

// AvailableScopesResponse respuesta con todos los scopes disponibles
type AvailableScopesResponse struct {
	TotalScopes int                      `json:"total_scopes"`
	Categories  map[string][]ScopeDetail `json:"categories"`
	Templates   []string                 `json:"templates"`
}

// ============================================================================
// Error Registry - Errores específicos de User
// ============================================================================

var ErrRegistry = errx.NewRegistry("USER")

// Códigos de error
var (
	CodeUserNotFound         = ErrRegistry.Register("NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Usuario no encontrado")
	CodeUserAlreadyExists    = ErrRegistry.Register("ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "El usuario ya existe")
	CodeUserNotInTenant      = ErrRegistry.Register("NOT_IN_TENANT", errx.TypeAuthorization, http.StatusForbidden, "Usuario no pertenece a la empresa")
	CodeEmailNotVerified     = ErrRegistry.Register("EMAIL_NOT_VERIFIED", errx.TypeBusiness, http.StatusPreconditionFailed, "Email no verificado")
	CodeUserSuspended        = ErrRegistry.Register("SUSPENDED", errx.TypeBusiness, http.StatusForbidden, "Usuario suspendido")
	CodeOnboardingRequired   = ErrRegistry.Register("ONBOARDING_REQUIRED", errx.TypeBusiness, http.StatusPreconditionRequired, "Se requiere completar el onboarding")
	CodeInvalidStatus        = ErrRegistry.Register("INVALID_STATUS", errx.TypeBusiness, http.StatusBadRequest, "Estado de usuario inválido para esta operación")
	CodeInvalidScopeTemplate = ErrRegistry.Register("INVALID_SCOPE_TEMPLATE", errx.TypeValidation, http.StatusBadRequest, "Plantilla de scopes no encontrada")
	CodeInvalidScopes        = ErrRegistry.Register("INVALID_SCOPES", errx.TypeValidation, http.StatusBadRequest, "Scopes inválidos")
	CodeScopeNotFound        = ErrRegistry.Register("SCOPE_NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Scope no encontrado")
	CodeInsufficientScopes   = ErrRegistry.Register("INSUFFICIENT_SCOPES", errx.TypeAuthorization, http.StatusForbidden, "Scopes insuficientes")
)

// Helper functions para crear errores
func ErrUserNotFound() *errx.Error {
	return ErrRegistry.New(CodeUserNotFound)
}

func ErrUserAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeUserAlreadyExists)
}

func ErrUserNotInTenant() *errx.Error {
	return ErrRegistry.New(CodeUserNotInTenant)
}

func ErrEmailNotVerified() *errx.Error {
	return ErrRegistry.New(CodeEmailNotVerified)
}

func ErrUserSuspended() *errx.Error {
	return ErrRegistry.New(CodeUserSuspended)
}

func ErrOnboardingRequired() *errx.Error {
	return ErrRegistry.New(CodeOnboardingRequired)
}

func ErrInvalidStatus() *errx.Error {
	return ErrRegistry.New(CodeInvalidStatus)
}

func ErrInvalidScopeTemplate() *errx.Error {
	return ErrRegistry.New(CodeInvalidScopeTemplate)
}

func ErrInvalidScopes() *errx.Error {
	return ErrRegistry.New(CodeInvalidScopes)
}

func ErrScopeNotFound() *errx.Error {
	return ErrRegistry.New(CodeScopeNotFound)
}

func ErrInsufficientScopes() *errx.Error {
	return ErrRegistry.New(CodeInsufficientScopes)
}
package user

import (
	"context"

	"github.com/Abraxas-365/manifesto/pkg/kernel"
)

// UserRepository define el contrato para la persistencia de usuarios
type UserRepository interface {
	FindByID(ctx context.Context, id kernel.UserID, tenantID kernel.TenantID) (*User, error)
	FindByEmail(ctx context.Context, email string, tenantID kernel.TenantID) (*User, error)
	FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*User, error)
	Save(ctx context.Context, u User) error
	Delete(ctx context.Context, id kernel.UserID, tenantID kernel.TenantID) error
	ExistsByEmail(ctx context.Context, email string, tenantID kernel.TenantID) (bool, error)
	FindByEmailAcrossTenants(ctx context.Context, email string) ([]*User, error)
}

// PasswordService define el contrato para el manejo de contraseñas
type PasswordService interface {
	HashPassword(password string) (string, error)
	VerifyPassword(hashedPassword, password string) bool
}
package userinfra

import (
	"context"
	"database/sql"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam"
	"github.com/Abraxas-365/manifesto/pkg/iam/user"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

// PostgresUserRepository implementación de PostgreSQL para UserRepository
type PostgresUserRepository struct {
	db *sqlx.DB
}

// NewPostgresUserRepository crea una nueva instancia del repositorio de usuarios
func NewPostgresUserRepository(db *sqlx.DB) user.UserRepository {
	return &PostgresUserRepository{
		db: db,
	}
}

// userDB is the database representation with pq.StringArray for scopes
type userDB struct {
	ID              string         `db:"id"`
	TenantID        string         `db:"tenant_id"`
	Email           string         `db:"email"`
	Name            string         `db:"name"`
	Picture         *string        `db:"picture"`
	Status          string         `db:"status"`
	Scopes          pq.StringArray `db:"scopes"`
	OAuthProvider   string         `db:"oauth_provider"`
	OAuthProviderID string         `db:"oauth_provider_id"`
	EmailVerified   bool           `db:"email_verified"`
	OTPEnabled      bool           `db:"otp_enabled"`
	LastLoginAt     sql.NullTime   `db:"last_login_at"` // ✅ NOT a pointer
	CreatedAt       time.Time      `db:"created_at"`    // ✅ Use time.Time directly
	UpdatedAt       time.Time      `db:"updated_at"`    // ✅ Use time.Time directly
}

// toDomain converts database model to domain model
func (db *userDB) toDomain() (*user.User, error) {
	u := &user.User{
		ID:              kernel.UserID(db.ID),
		TenantID:        kernel.TenantID(db.TenantID),
		Email:           db.Email,
		Name:            db.Name,
		Picture:         db.Picture,
		Status:          user.UserStatus(db.Status),
		Scopes:          []string(db.Scopes),
		OAuthProvider:   iam.OAuthProvider(db.OAuthProvider),
		OAuthProviderID: db.OAuthProviderID,
		EmailVerified:   db.EmailVerified,
		OTPEnabled:      db.OTPEnabled,
		CreatedAt:       db.CreatedAt,
		UpdatedAt:       db.UpdatedAt,
	}

	if db.LastLoginAt.Valid {
		u.LastLoginAt = &db.LastLoginAt.Time
	}

	return u, nil
}

// fromDomain converts domain model to database model
func fromDomain(u *user.User) *userDB {
	db := &userDB{
		ID:              u.ID.String(),
		TenantID:        u.TenantID.String(),
		Email:           u.Email,
		Name:            u.Name,
		Picture:         u.Picture,
		Status:          string(u.Status),
		Scopes:          pq.StringArray(u.Scopes),
		OAuthProvider:   string(u.OAuthProvider),
		OAuthProviderID: u.OAuthProviderID,
		EmailVerified:   u.EmailVerified,
		OTPEnabled:      u.OTPEnabled,
		CreatedAt:       u.CreatedAt,
		UpdatedAt:       u.UpdatedAt,
	}

	if u.LastLoginAt != nil {
		db.LastLoginAt = sql.NullTime{Time: *u.LastLoginAt, Valid: true}
	}

	return db
}

// FindByID busca un usuario por ID y tenant
func (r *PostgresUserRepository) FindByID(ctx context.Context, id kernel.UserID, tenantID kernel.TenantID) (*user.User, error) {
	query := `
		SELECT
			id, tenant_id, email, name, picture, status, scopes,
			oauth_provider, oauth_provider_id, email_verified, otp_enabled,
			last_login_at, created_at, updated_at
		FROM users
		WHERE id = $1 AND tenant_id = $2`

	var dbUser userDB
	err := r.db.GetContext(ctx, &dbUser, query, id.String(), tenantID.String())
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, user.ErrUserNotFound().WithDetail("user_id", id.String())
		}
		return nil, errx.Wrap(err, "failed to find user by id", errx.TypeInternal).
			WithDetail("user_id", id.String()).
			WithDetail("tenant_id", tenantID.String())
	}

	return dbUser.toDomain()
}

// FindByEmail busca un usuario por email y tenant
func (r *PostgresUserRepository) FindByEmail(ctx context.Context, email string, tenantID kernel.TenantID) (*user.User, error) {
	query := `
		SELECT
			id, tenant_id, email, name, picture, status, scopes,
			oauth_provider, oauth_provider_id, email_verified, otp_enabled,
			last_login_at, created_at, updated_at
		FROM users
		WHERE email = $1 AND tenant_id = $2`

	var dbUser userDB
	err := r.db.GetContext(ctx, &dbUser, query, email, tenantID.String())
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, user.ErrUserNotFound().WithDetail("email", email)
		}
		return nil, errx.Wrap(err, "failed to find user by email", errx.TypeInternal).
			WithDetail("email", email).
			WithDetail("tenant_id", tenantID.String())
	}

	return dbUser.toDomain()
}

// FindByEmailAcrossTenants finds all users with this email across all tenants
func (r *PostgresUserRepository) FindByEmailAcrossTenants(ctx context.Context, email string) ([]*user.User, error) {
	query := `
		SELECT
			id, tenant_id, email, name, picture, status, scopes,
			oauth_provider, oauth_provider_id, email_verified, otp_enabled,
			last_login_at, created_at, updated_at
		FROM users
		WHERE email = $1
		ORDER BY created_at DESC`

	var dbUsers []userDB
	err := r.db.SelectContext(ctx, &dbUsers, query, email)
	if err != nil {
		return nil, errx.Wrap(err, "failed to find users by email across tenants", errx.TypeInternal).
			WithDetail("email", email)
	}

	// Convert to domain models
	result := make([]*user.User, len(dbUsers))
	for i := range dbUsers {
		domainUser, err := dbUsers[i].toDomain()
		if err != nil {
			return nil, err
		}
		result[i] = domainUser
	}

	return result, nil
}

// FindByTenant busca todos los usuarios de un tenant
func (r *PostgresUserRepository) FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*user.User, error) {
	query := `
		SELECT
			id, tenant_id, email, name, picture, status, scopes,
			oauth_provider, oauth_provider_id, email_verified, otp_enabled,
			last_login_at, created_at, updated_at
		FROM users
		WHERE tenant_id = $1
		ORDER BY name ASC`

	var dbUsers []userDB
	err := r.db.SelectContext(ctx, &dbUsers, query, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find users by tenant", errx.TypeInternal).
			WithDetail("tenant_id", tenantID.String())
	}

	// Convert to domain models
	result := make([]*user.User, len(dbUsers))
	for i := range dbUsers {
		domainUser, err := dbUsers[i].toDomain()
		if err != nil {
			return nil, err
		}
		result[i] = domainUser
	}

	return result, nil
}

// Save guarda o actualiza un usuario
func (r *PostgresUserRepository) Save(ctx context.Context, u user.User) error {
	exists, err := r.userExists(ctx, u.ID, u.TenantID)
	if err != nil {
		return errx.Wrap(err, "failed to check user existence", errx.TypeInternal)
	}

	if exists {
		return r.update(ctx, u)
	}
	return r.create(ctx, u)
}

// create crea un nuevo usuario
func (r *PostgresUserRepository) create(ctx context.Context, u user.User) error {
	query := `
		INSERT INTO users (
			id, tenant_id, email, name, picture, status, scopes,
			oauth_provider, oauth_provider_id, email_verified, otp_enabled,
			last_login_at, created_at, updated_at
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
		)`

	_, err := r.db.ExecContext(ctx, query,
		u.ID.String(),
		u.TenantID.String(),
		u.Email,
		u.Name,
		u.Picture,
		u.Status,
		pq.Array(u.Scopes),
		u.OAuthProvider,
		u.OAuthProviderID,
		u.EmailVerified,
		u.OTPEnabled,
		u.LastLoginAt,
		u.CreatedAt,
		u.UpdatedAt,
	)

	if err != nil {
		if pqErr, ok := err.(*pq.Error); ok {
			if pqErr.Code == "23505" && pqErr.Constraint == "uq_users_email_tenant" {
				return user.ErrUserAlreadyExists().
					WithDetail("email", u.Email).
					WithDetail("tenant_id", u.TenantID.String())
			}
		}
		return errx.Wrap(err, "failed to create user", errx.TypeInternal).
			WithDetail("user_id", u.ID.String()).
			WithDetail("email", u.Email)
	}

	return nil
}

// update actualiza un usuario existente
func (r *PostgresUserRepository) update(ctx context.Context, u user.User) error {
	query := `
		UPDATE users SET
			email = $1,
			name = $2,
			picture = $3,
			status = $4,
			scopes = $5,
			oauth_provider = $6,
			oauth_provider_id = $7,
			email_verified = $8,
			otp_enabled = $9,
			last_login_at = $10,
			updated_at = $11
		WHERE id = $12 AND tenant_id = $13`

	result, err := r.db.ExecContext(ctx, query,
		u.Email,
		u.Name,
		u.Picture,
		u.Status,
		pq.Array(u.Scopes),
		u.OAuthProvider,
		u.OAuthProviderID,
		u.EmailVerified,
		u.OTPEnabled,
		u.LastLoginAt,
		u.UpdatedAt,
		u.ID.String(),
		u.TenantID.String(),
	)

	if err != nil {
		if pqErr, ok := err.(*pq.Error); ok {
			if pqErr.Code == "23505" && pqErr.Constraint == "uq_users_email_tenant" {
				return user.ErrUserAlreadyExists().
					WithDetail("email", u.Email).
					WithDetail("tenant_id", u.TenantID.String())
			}
		}
		return errx.Wrap(err, "failed to update user", errx.TypeInternal).
			WithDetail("user_id", u.ID.String())
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return user.ErrUserNotFound().WithDetail("user_id", u.ID.String())
	}

	return nil
}

// Delete elimina un usuario
func (r *PostgresUserRepository) Delete(ctx context.Context, id kernel.UserID, tenantID kernel.TenantID) error {
	query := `DELETE FROM users WHERE id = $1 AND tenant_id = $2`

	result, err := r.db.ExecContext(ctx, query, id.String(), tenantID.String())
	if err != nil {
		return errx.Wrap(err, "failed to delete user", errx.TypeInternal).
			WithDetail("user_id", id.String()).
			WithDetail("tenant_id", tenantID.String())
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return user.ErrUserNotFound().WithDetail("user_id", id.String())
	}

	return nil
}

// ExistsByEmail verifica si existe un usuario con el email dado en el tenant
func (r *PostgresUserRepository) ExistsByEmail(ctx context.Context, email string, tenantID kernel.TenantID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM users WHERE email = $1 AND tenant_id = $2)`

	var exists bool
	err := r.db.GetContext(ctx, &exists, query, email, tenantID.String())
	if err != nil {
		return false, errx.Wrap(err, "failed to check user existence by email", errx.TypeInternal).
			WithDetail("email", email).
			WithDetail("tenant_id", tenantID.String())
	}

	return exists, nil
}

// userExists verifica si un usuario existe por ID y tenant
func (r *PostgresUserRepository) userExists(ctx context.Context, id kernel.UserID, tenantID kernel.TenantID) (bool, error) {
	query := `SELECT EXISTS(SELECT 1 FROM users WHERE id = $1 AND tenant_id = $2)`

	var exists bool
	err := r.db.GetContext(ctx, &exists, query, id.String(), tenantID.String())
	if err != nil {
		return false, errx.Wrap(err, "failed to check user existence", errx.TypeInternal).
			WithDetail("user_id", id.String()).
			WithDetail("tenant_id", tenantID.String())
	}

	return exists, nil
}

// FindByStatus busca usuarios por estado
func (r *PostgresUserRepository) FindByStatus(ctx context.Context, status user.UserStatus, tenantID kernel.TenantID) ([]*user.User, error) {
	query := `
		SELECT
			id, tenant_id, email, name, picture, status, scopes,
			oauth_provider, oauth_provider_id, email_verified, otp_enabled,
			last_login_at, created_at, updated_at
		FROM users
		WHERE status = $1 AND tenant_id = $2
		ORDER BY name ASC`

	var dbUsers []userDB
	err := r.db.SelectContext(ctx, &dbUsers, query, status, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find users by status", errx.TypeInternal).
			WithDetail("status", string(status)).
			WithDetail("tenant_id", tenantID.String())
	}

	result := make([]*user.User, len(dbUsers))
	for i := range dbUsers {
		domainUser, err := dbUsers[i].toDomain()
		if err != nil {
			return nil, err
		}
		result[i] = domainUser
	}

	return result, nil
}

// FindActiveUsers busca usuarios activos
func (r *PostgresUserRepository) FindActiveUsers(ctx context.Context, tenantID kernel.TenantID) ([]*user.User, error) {
	return r.FindByStatus(ctx, user.UserStatusActive, tenantID)
}

// CountByTenant cuenta los usuarios de un tenant
func (r *PostgresUserRepository) CountByTenant(ctx context.Context, tenantID kernel.TenantID) (int, error) {
	query := `SELECT COUNT(*) FROM users WHERE tenant_id = $1`

	var count int
	err := r.db.GetContext(ctx, &count, query, tenantID.String())
	if err != nil {
		return 0, errx.Wrap(err, "failed to count users by tenant", errx.TypeInternal).
			WithDetail("tenant_id", tenantID.String())
	}

	return count, nil
}

// FindByOAuthProvider busca un usuario por proveedor OAuth y ID
func (r *PostgresUserRepository) FindByOAuthProvider(ctx context.Context, provider string, providerID string, tenantID kernel.TenantID) (*user.User, error) {
	query := `
		SELECT
			id, tenant_id, email, name, picture, status, scopes,
			oauth_provider, oauth_provider_id, email_verified, otp_enabled,
			last_login_at, created_at, updated_at
		FROM users
		WHERE oauth_provider = $1 AND oauth_provider_id = $2 AND tenant_id = $3`

	var dbUser userDB
	err := r.db.GetContext(ctx, &dbUser, query, provider, providerID, tenantID.String())
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, user.ErrUserNotFound().
				WithDetail("oauth_provider", provider).
				WithDetail("oauth_provider_id", providerID)
		}
		return nil, errx.Wrap(err, "failed to find user by oauth provider", errx.TypeInternal).
			WithDetail("oauth_provider", provider).
			WithDetail("oauth_provider_id", providerID).
			WithDetail("tenant_id", tenantID.String())
	}

	return dbUser.toDomain()
}
package usersrv

import (
	"context"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam/scopes"
	"github.com/Abraxas-365/manifesto/pkg/iam/tenant"
	"github.com/Abraxas-365/manifesto/pkg/iam/user"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/google/uuid"
)

// UserService proporciona operaciones de negocio para usuarios
type UserService struct {
	userRepo    user.UserRepository
	tenantRepo  tenant.TenantRepository
	passwordSvc user.PasswordService
}

// NewUserService crea una nueva instancia del servicio de usuarios
func NewUserService(
	userRepo user.UserRepository,
	tenantRepo tenant.TenantRepository,
	passwordSvc user.PasswordService,
) *UserService {
	return &UserService{
		userRepo:    userRepo,
		tenantRepo:  tenantRepo,
		passwordSvc: passwordSvc,
	}
}

// CreateUser crea un nuevo usuario
func (s *UserService) CreateUser(ctx context.Context, req user.CreateUserRequest, creatorID kernel.UserID) (*user.User, error) {
	// Validar que el tenant exista y esté activo
	tenantEntity, err := s.tenantRepo.FindByID(ctx, req.TenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	if !tenantEntity.IsActive() {
		return nil, tenant.ErrTenantSuspended()
	}

	// Verificar que el tenant puede agregar más usuarios
	if !tenantEntity.CanAddUser() {
		return nil, tenant.ErrMaxUsersReached()
	}

	// Verificar que no exista un usuario con el mismo email
	exists, err := s.userRepo.ExistsByEmail(ctx, req.Email, req.TenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to check email existence", errx.TypeInternal)
	}
	if exists {
		return nil, user.ErrUserAlreadyExists()
	}

	// Determinar scopes
	scopes, err := s.resolveScopes(req)
	if err != nil {
		return nil, err
	}

	// Validar scopes
	if err := s.validateScopes(scopes); err != nil {
		return nil, err
	}

	// Crear nuevo usuario
	newUser := &user.User{
		ID:            kernel.NewUserID(uuid.NewString()),
		TenantID:      req.TenantID,
		Email:         req.Email,
		Name:          req.Name,
		Status:        user.UserStatusPending, // Pendiente hasta completar onboarding
		Scopes:        scopes,
		EmailVerified: false, // Se verificará después
		CreatedAt:     time.Now(),
		UpdatedAt:     time.Now(),
	}

	// Guardar usuario
	if err := s.userRepo.Save(ctx, *newUser); err != nil {
		return nil, errx.Wrap(err, "failed to save user", errx.TypeInternal)
	}

	// Incrementar contador de usuarios del tenant
	if err := tenantEntity.AddUser(); err == nil {
		s.tenantRepo.Save(ctx, *tenantEntity)
	}

	return newUser, nil
}

// GetUserByID obtiene un usuario por ID
func (s *UserService) GetUserByID(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID) (*user.UserResponse, error) {
	userEntity, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return nil, user.ErrUserNotFound()
	}

	return &user.UserResponse{
		User: *userEntity,
	}, nil
}

// GetUserByEmail obtiene un usuario por email
func (s *UserService) GetUserByEmail(ctx context.Context, email string, tenantID kernel.TenantID) (*user.UserResponse, error) {
	userEntity, err := s.userRepo.FindByEmail(ctx, email, tenantID)
	if err != nil {
		return nil, user.ErrUserNotFound()
	}

	return &user.UserResponse{
		User: *userEntity,
	}, nil
}

// GetUsersByTenant obtiene todos los usuarios de un tenant
func (s *UserService) GetUsersByTenant(ctx context.Context, tenantID kernel.TenantID) (*user.UserListResponse, error) {
	users, err := s.userRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get users by tenant", errx.TypeInternal)
	}

	var userResponses []user.UserResponse
	for _, u := range users {
		userResponses = append(userResponses, user.UserResponse{
			User: *u,
		})
	}

	return &user.UserListResponse{
		Users: userResponses,
		Total: len(userResponses),
	}, nil
}

// UpdateUser actualiza un usuario
func (s *UserService) UpdateUser(ctx context.Context, userID kernel.UserID, req user.UpdateUserRequest, updaterID kernel.UserID) (*user.User, error) {
	userEntity, err := s.userRepo.FindByID(ctx, userID, req.TenantID)
	if err != nil {
		return nil, user.ErrUserNotFound()
	}

	// Actualizar campos si se proporcionaron
	if req.Name != nil {
		userEntity.Name = *req.Name
	}

	if req.Status != nil {
		switch *req.Status {
		case user.UserStatusActive:
			if err := userEntity.Activate(); err != nil {
				return nil, err
			}
		case user.UserStatusSuspended:
			if err := userEntity.Suspend("Updated by admin"); err != nil {
				return nil, err
			}
		}
	}

	// Actualizar scopes si se proporcionaron
	if req.Scopes != nil && len(req.Scopes) > 0 {
		if err := s.validateScopes(req.Scopes); err != nil {
			return nil, err
		}
		userEntity.SetScopes(req.Scopes)
	}

	// Aplicar scope template si se proporciona
	if req.ScopeTemplate != nil && *req.ScopeTemplate != "" {
		scopes := scopes.GetScopesByGroup(*req.ScopeTemplate)
		if len(scopes) == 0 {
			return nil, user.ErrInvalidScopeTemplate().
				WithDetail("template", *req.ScopeTemplate).
				WithDetail("available_templates", s.GetAvailableScopeTemplates())
		}
		userEntity.SetScopes(scopes)
	}

	userEntity.UpdatedAt = time.Now()

	// Guardar cambios
	if err := s.userRepo.Save(ctx, *userEntity); err != nil {
		return nil, errx.Wrap(err, "failed to update user", errx.TypeInternal)
	}

	return userEntity, nil
}

// ActivateUser activa un usuario pendiente
func (s *UserService) ActivateUser(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID) error {
	userEntity, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	if err := userEntity.Activate(); err != nil {
		return err
	}

	return s.userRepo.Save(ctx, *userEntity)
}

// SuspendUser suspende un usuario
func (s *UserService) SuspendUser(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID, reason string) error {
	userEntity, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	if err := userEntity.Suspend(reason); err != nil {
		return err
	}

	return s.userRepo.Save(ctx, *userEntity)
}

// DeleteUser elimina un usuario
func (s *UserService) DeleteUser(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID) error {
	// Verificar que el usuario existe
	_, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	// Eliminar usuario
	if err := s.userRepo.Delete(ctx, userID, tenantID); err != nil {
		return errx.Wrap(err, "failed to delete user", errx.TypeInternal)
	}

	// Decrementar contador de usuarios del tenant
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err == nil {
		tenantEntity.RemoveUser()
		s.tenantRepo.Save(ctx, *tenantEntity)
	}

	return nil
}

// ============================================================================
// Scope Management Methods
// ============================================================================

// AddScopesToUser agrega scopes a un usuario
func (s *UserService) AddScopesToUser(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID, scopes []string) error {
	userEntity, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	// Validar scopes
	if err := s.validateScopes(scopes); err != nil {
		return err
	}

	// Agregar scopes (evitando duplicados)
	for _, scope := range scopes {
		if !userEntity.HasScope(scope) {
			userEntity.AddScope(scope)
		}
	}

	return s.userRepo.Save(ctx, *userEntity)
}

// RemoveScopesFromUser remueve scopes de un usuario
func (s *UserService) RemoveScopesFromUser(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID, scopes []string) error {
	userEntity, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	// Remover scopes
	for _, scope := range scopes {
		userEntity.RemoveScope(scope)
	}

	return s.userRepo.Save(ctx, *userEntity)
}

// SetUserScopes establece los scopes de un usuario (reemplaza los existentes)
func (s *UserService) SetUserScopes(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID, scopes []string) error {
	userEntity, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	// Validar scopes
	if err := s.validateScopes(scopes); err != nil {
		return err
	}

	userEntity.SetScopes(scopes)
	return s.userRepo.Save(ctx, *userEntity)
}

// ApplyScopeTemplateToUser aplica una plantilla de scopes a un usuario
func (s *UserService) ApplyScopeTemplateToUser(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID, templateName string) error {
	userEntity, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	scopes := scopes.GetScopesByGroup(templateName)
	if len(scopes) == 0 {
		return user.ErrInvalidScopeTemplate().
			WithDetail("template", templateName).
			WithDetail("available_templates", s.GetAvailableScopeTemplates())
	}

	userEntity.SetScopes(scopes)
	return s.userRepo.Save(ctx, *userEntity)
}

// GetUserScopes obtiene los scopes de un usuario
func (s *UserService) GetUserScopes(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID) (*user.UserScopesResponse, error) {
	userEntity, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return nil, user.ErrUserNotFound()
	}

	// Construir información detallada de scopes
	scopeDetails := make([]user.ScopeDetail, 0, len(userEntity.Scopes))
	for _, scope := range userEntity.Scopes {
		scopeDetails = append(scopeDetails, user.ScopeDetail{
			Name:        scope,
			Description: scopes.GetScopeDescription(scope),
			Category:    scopes.GetScopeCategory(scope),
		})
	}

	return &user.UserScopesResponse{
		UserID:       userID,
		Scopes:       userEntity.Scopes,
		ScopeDetails: scopeDetails,
		TotalScopes:  len(userEntity.Scopes),
		IsAdmin:      userEntity.IsAdmin(),
	}, nil
}

// MakeUserAdmin convierte a un usuario en administrador
func (s *UserService) MakeUserAdmin(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID) error {
	userEntity, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	userEntity.MakeAdmin()
	return s.userRepo.Save(ctx, *userEntity)
}

// RevokeUserAdmin revoca permisos de administrador
func (s *UserService) RevokeUserAdmin(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID) error {
	userEntity, err := s.userRepo.FindByID(ctx, userID, tenantID)
	if err != nil {
		return user.ErrUserNotFound()
	}

	userEntity.RevokeAdmin()
	return s.userRepo.Save(ctx, *userEntity)
}

// GetAvailableScopeTemplates retorna las plantillas de scopes disponibles
func (s *UserService) GetAvailableScopeTemplates() []string {
	templates := make([]string, 0, len(scopes.ScopeGroups))
	for template := range scopes.ScopeGroups {
		templates = append(templates, template)
	}
	return templates
}

// GetScopeTemplateDetails obtiene los detalles de una plantilla
func (s *UserService) GetScopeTemplateDetails(templateName string) (*user.ScopeTemplateResponse, error) {
	scopesl := scopes.GetScopesByGroup(templateName)
	if len(scopesl) == 0 {
		return nil, user.ErrInvalidScopeTemplate().WithDetail("template", templateName)
	}

	scopeDetails := make([]user.ScopeDetail, 0, len(scopesl))
	for _, scope := range scopesl {
		scopeDetails = append(scopeDetails, user.ScopeDetail{
			Name:        scope,
			Description: scopes.GetScopeDescription(scope),
			Category:    scopes.GetScopeCategory(scope),
		})
	}

	return &user.ScopeTemplateResponse{
		TemplateName: templateName,
		Scopes:       scopesl,
		ScopeDetails: scopeDetails,
		TotalScopes:  len(scopesl),
	}, nil
}

// GetAllAvailableScopes retorna todos los scopes disponibles del sistema
func (s *UserService) GetAllAvailableScopes() *user.AvailableScopesResponse {
	allScopes := scopes.GetAllScopes()
	categories := make(map[string][]user.ScopeDetail)

	// Agrupar por categoría
	for _, scope := range allScopes {
		category := scopes.GetScopeCategory(scope)
		scopeDetail := user.ScopeDetail{
			Name:        scope,
			Description: scopes.GetScopeDescription(scope),
			Category:    category,
		}
		categories[category] = append(categories[category], scopeDetail)
	}

	return &user.AvailableScopesResponse{
		TotalScopes: len(allScopes),
		Categories:  categories,
		Templates:   s.GetAvailableScopeTemplates(),
	}
}

// ============================================================================
// Private Helper Methods
// ============================================================================

// resolveScopes determina los scopes finales basándose en la request
func (s *UserService) resolveScopes(req user.CreateUserRequest) ([]string, error) {
	// Si se proporcionan scopes directamente, usarlos
	if len(req.Scopes) > 0 {
		return req.Scopes, nil
	}

	// Si se proporciona un template, expandirlo
	if req.ScopeTemplate != nil && *req.ScopeTemplate != "" {
		scopes := scopes.GetScopesByGroup(*req.ScopeTemplate)
		if len(scopes) == 0 {
			return nil, user.ErrInvalidScopeTemplate().
				WithDetail("template", *req.ScopeTemplate).
				WithDetail("available_templates", s.GetAvailableScopeTemplates())
		}
		return scopes, nil
	}

	// Default: usar template "viewer" o scopes básicos
	defaultScopes := scopes.GetScopesByGroup("viewer")

	return defaultScopes, nil
}

// validateScopes valida que los scopes sean válidos
func (s *UserService) validateScopes(scopesl []string) error {
	if len(scopesl) == 0 {
		return user.ErrInvalidScopes().WithDetail("reason", "at least one scope is required")
	}

	// Validar cada scope
	invalidScopes := []string{}
	for _, scope := range scopesl {
		if !scopes.ValidateScope(scope) {
			invalidScopes = append(invalidScopes, scope)
		}
	}

	if len(invalidScopes) > 0 {
		return user.ErrInvalidScopes().
			WithDetail("invalid_scopes", invalidScopes).
			WithDetail("hint", "Use GetAllAvailableScopes() to see valid scopes")
	}

	return nil
}
package apikeyapi

import (
	"github.com/Abraxas-365/manifesto/pkg/iam"
	"github.com/Abraxas-365/manifesto/pkg/iam/apikey"
	"github.com/Abraxas-365/manifesto/pkg/iam/apikey/apikeysrv"
	"github.com/Abraxas-365/manifesto/pkg/iam/auth"
	"github.com/gofiber/fiber/v2"
)

type APIKeyHandlers struct {
	service *apikeysrv.APIKeyService
}

func NewAPIKeyHandlers(service *apikeysrv.APIKeyService) *APIKeyHandlers {
	return &APIKeyHandlers{service: service}
}

func (h *APIKeyHandlers) RegisterRoutes(router fiber.Router, authMiddleware *auth.UnifiedAuthMiddleware) {
	keys := router.Group("/api-keys", authMiddleware.Authenticate())

	keys.Post("/", h.CreateAPIKey)
	keys.Get("/", h.GetTenantAPIKeys)
	keys.Get("/:id", h.GetAPIKey)
	keys.Put("/:id", h.UpdateAPIKey)
	keys.Post("/:id/revoke", h.RevokeAPIKey)
	keys.Delete("/:id", h.DeleteAPIKey)
}

func (h *APIKeyHandlers) CreateAPIKey(c *fiber.Ctx) error {
	authContext, ok := auth.GetAuthContext(c)
	if !ok {
		return iam.ErrUnauthorized()
	}

	var req apikey.CreateAPIKeyRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Invalid request body"})
	}

	response, err := h.service.CreateAPIKey(c.Context(), authContext.TenantID, *authContext.UserID, req)
	if err != nil {
		return err
	}

	return c.Status(fiber.StatusCreated).JSON(response)
}

func (h *APIKeyHandlers) GetTenantAPIKeys(c *fiber.Ctx) error {
	authContext, ok := auth.GetAuthContext(c)
	if !ok {
		return iam.ErrUnauthorized()
	}

	response, err := h.service.GetTenantAPIKeys(c.Context(), authContext.TenantID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": err.Error()})
	}

	return c.JSON(response)
}

func (h *APIKeyHandlers) GetAPIKey(c *fiber.Ctx) error {
	authContext, ok := auth.GetAuthContext(c)
	if !ok {
		return iam.ErrUnauthorized()
	}

	keyID := c.Params("id")
	key, err := h.service.GetAPIKeyByID(c.Context(), keyID, authContext.TenantID)
	if err != nil {
		return err
	}

	return c.JSON(key)
}

func (h *APIKeyHandlers) UpdateAPIKey(c *fiber.Ctx) error {
	authContext, ok := auth.GetAuthContext(c)
	if !ok {
		return iam.ErrUnauthorized()
	}

	keyID := c.Params("id")
	var req apikey.UpdateAPIKeyRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "Invalid request body"})
	}

	key, err := h.service.UpdateAPIKey(c.Context(), keyID, authContext.TenantID, req)
	if err != nil {
		return err
	}

	return c.JSON(key)
}

func (h *APIKeyHandlers) RevokeAPIKey(c *fiber.Ctx) error {
	authContext, ok := auth.GetAuthContext(c)
	if !ok {
		return iam.ErrUnauthorized()
	}

	keyID := c.Params("id")
	if err := h.service.RevokeAPIKey(c.Context(), keyID, authContext.TenantID); err != nil {
		return err
	}

	return c.JSON(fiber.Map{"message": "API key revoked successfully"})
}

func (h *APIKeyHandlers) DeleteAPIKey(c *fiber.Ctx) error {
	authContext, ok := auth.GetAuthContext(c)
	if !ok {
		return iam.ErrUnauthorized()
	}

	keyID := c.Params("id")
	if err := h.service.DeleteAPIKey(c.Context(), keyID, authContext.TenantID); err != nil {
		return err
	}

	return c.JSON(fiber.Map{"message": "API key deleted successfully"})
}
package apikey

import (
	"context"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
)

type APIKeyRepository interface {
	Save(ctx context.Context, key APIKey) error
	FindByID(ctx context.Context, id string, tenantID kernel.TenantID) (*APIKey, error)
	FindByHash(ctx context.Context, keyHash string) (*APIKey, error)
	FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*APIKey, error)
	FindActiveByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*APIKey, error)
	FindByUser(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID) ([]*APIKey, error)
	Delete(ctx context.Context, id string, tenantID kernel.TenantID) error
	UpdateLastUsed(ctx context.Context, id string) error
}
package apikeysrv

import (
	"context"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam/apikey"
	"github.com/Abraxas-365/manifesto/pkg/iam/tenant"
	"github.com/Abraxas-365/manifesto/pkg/iam/user"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/google/uuid"
)

type APIKeyService struct {
	apiKeyRepo apikey.APIKeyRepository
	tenantRepo tenant.TenantRepository
	userRepo   user.UserRepository
}

func NewAPIKeyService(
	apiKeyRepo apikey.APIKeyRepository,
	tenantRepo tenant.TenantRepository,
	userRepo user.UserRepository,
) *APIKeyService {
	return &APIKeyService{
		apiKeyRepo: apiKeyRepo,
		tenantRepo: tenantRepo,
		userRepo:   userRepo,
	}
}

func (s *APIKeyService) CreateAPIKey(
	ctx context.Context,
	tenantID kernel.TenantID,
	creatorID kernel.UserID,
	req apikey.CreateAPIKeyRequest,
) (*apikey.CreateAPIKeyResponse, error) {
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, err
	}
	if !tenantEntity.IsActive() {
		return nil, tenant.ErrTenantSuspended()
	}

	_, err = s.userRepo.FindByID(ctx, creatorID, tenantID)
	if err != nil {
		return nil, err
	}

	if req.UserID != nil {
		_, err := s.userRepo.FindByID(ctx, *req.UserID, tenantID)
		if err != nil {
			return nil, user.ErrUserNotFound()
		}
	}

	var prefix string
	if req.Environment == "live" {
		prefix = apikey.KeyPrefixLive
	} else {
		prefix = apikey.KeyPrefixTest
	}

	generated, err := apikey.GenerateAPIKey(prefix)
	if err != nil {
		return nil, err
	}

	var expiresAt *time.Time
	if req.ExpiresIn != nil && *req.ExpiresIn > 0 {
		expiration := time.Now().AddDate(0, 0, *req.ExpiresIn)
		expiresAt = &expiration
	}

	newKey := apikey.APIKey{
		ID:          uuid.NewString(),
		KeyHash:     apikey.HashAPIKey(generated.Key),
		KeyPrefix:   generated.KeyPrefix,
		TenantID:    tenantID,
		UserID:      req.UserID,
		Name:        req.Name,
		Description: req.Description,
		Scopes:      req.Scopes,
		IsActive:    true,
		ExpiresAt:   expiresAt,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	if err := s.apiKeyRepo.Save(ctx, newKey); err != nil {
		return nil, errx.Wrap(err, "failed to save API key", errx.TypeInternal)
	}

	return &apikey.CreateAPIKeyResponse{
		APIKey:    newKey.ToDTO(),
		SecretKey: generated.Key,
		Message:   "⚠️ Save this key securely. It will not be shown again!",
	}, nil
}

func (s *APIKeyService) GetAPIKeyByID(
	ctx context.Context,
	keyID string,
	tenantID kernel.TenantID,
) (*apikey.APIKeyDTO, error) {
	key, err := s.apiKeyRepo.FindByID(ctx, keyID, tenantID)
	if err != nil {
		return nil, apikey.ErrAPIKeyNotFound()
	}

	dto := key.ToDTO()
	return &dto, nil
}

func (s *APIKeyService) GetTenantAPIKeys(
	ctx context.Context,
	tenantID kernel.TenantID,
) (*apikey.APIKeyListResponse, error) {
	keys, err := s.apiKeyRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get API keys", errx.TypeInternal)
	}

	dtos := make([]apikey.APIKeyDTO, 0, len(keys))
	for _, key := range keys {
		dtos = append(dtos, key.ToDTO())
	}

	return &apikey.APIKeyListResponse{
		APIKeys: dtos,
		Total:   len(dtos),
	}, nil
}

func (s *APIKeyService) UpdateAPIKey(
	ctx context.Context,
	keyID string,
	tenantID kernel.TenantID,
	req apikey.UpdateAPIKeyRequest,
) (*apikey.APIKeyDTO, error) {
	key, err := s.apiKeyRepo.FindByID(ctx, keyID, tenantID)
	if err != nil {
		return nil, apikey.ErrAPIKeyNotFound()
	}

	if req.Name != nil {
		key.Name = *req.Name
	}
	if req.Description != nil {
		key.Description = *req.Description
	}
	if req.Scopes != nil {
		key.Scopes = req.Scopes
	}
	if req.IsActive != nil {
		key.IsActive = *req.IsActive
	}

	key.UpdatedAt = time.Now()

	if err := s.apiKeyRepo.Save(ctx, *key); err != nil {
		return nil, errx.Wrap(err, "failed to update API key", errx.TypeInternal)
	}

	dto := key.ToDTO()
	return &dto, nil
}
func (s *APIKeyService) RevokeAPIKey(
	ctx context.Context,
	keyID string,
	tenantID kernel.TenantID,
) error {
	key, err := s.apiKeyRepo.FindByID(ctx, keyID, tenantID)
	if err != nil {
		return apikey.ErrAPIKeyNotFound()
	}

	key.Revoke()
	return s.apiKeyRepo.Save(ctx, *key)
}

func (s *APIKeyService) DeleteAPIKey(
	ctx context.Context,
	keyID string,
	tenantID kernel.TenantID,
) error {
	_, err := s.apiKeyRepo.FindByID(ctx, keyID, tenantID)
	if err != nil {
		return apikey.ErrAPIKeyNotFound()
	}

	return s.apiKeyRepo.Delete(ctx, keyID, tenantID)
}

func (s *APIKeyService) ValidateAPIKey(
	ctx context.Context,
	keyString string,
) (*apikey.APIKey, error) {
	if !apikey.ValidateAPIKeyFormat(keyString) {
		return nil, apikey.ErrAPIKeyInvalid()
	}

	keyHash := apikey.HashAPIKey(keyString)
	key, err := s.apiKeyRepo.FindByHash(ctx, keyHash)
	if err != nil {
		return nil, apikey.ErrAPIKeyNotFound()
	}

	if !key.IsValid() {
		if key.IsExpired() {
			return nil, apikey.ErrAPIKeyExpired()
		}
		return nil, apikey.ErrAPIKeyRevoked()
	}

	go s.apiKeyRepo.UpdateLastUsed(context.Background(), key.ID)

	return key, nil
}
package apikeyinfra

import (
	"context"
	"database/sql"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam/apikey"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

// PostgresAPIKeyRepository es la implementación en PostgreSQL de APIKeyRepository.
type PostgresAPIKeyRepository struct {
	db *sqlx.DB
}

// NewPostgresAPIKeyRepository crea una nueva instancia del repositorio.
func NewPostgresAPIKeyRepository(db *sqlx.DB) apikey.APIKeyRepository {
	return &PostgresAPIKeyRepository{
		db: db,
	}
}

// Save inserta o actualiza una APIKey.
func (r *PostgresAPIKeyRepository) Save(ctx context.Context, key apikey.APIKey) error {
	exists, err := r.keyExists(ctx, key.ID)
	if err != nil {
		return errx.Wrap(err, "failed to check API key existence", errx.TypeInternal)
	}

	if exists {
		return r.update(ctx, key)
	}
	return r.create(ctx, key)
}

func (r *PostgresAPIKeyRepository) create(ctx context.Context, key apikey.APIKey) error {
	query := `
		INSERT INTO api_keys (
			id, key_hash, key_prefix, tenant_id, user_id, name, description,
			scopes, is_active, expires_at, last_used_at, created_at, updated_at
		) VALUES (
			:id, :key_hash, :key_prefix, :tenant_id, :user_id, :name, :description,
			:scopes, :is_active, :expires_at, :last_used_at, :created_at, :updated_at
		)`

	keyWithPGArray := toPersistence(key)

	_, err := r.db.NamedExecContext(ctx, query, keyWithPGArray)
	if err != nil {
		if pqErr, ok := err.(*pq.Error); ok && pqErr.Code == "23505" { // unique_violation
			return apikey.ErrAPIKeyInvalid().WithDetail("reason", "key name or hash already exists")
		}
		return errx.Wrap(err, "failed to create API key", errx.TypeInternal).
			WithDetail("key_id", key.ID)
	}
	return nil
}

func (r *PostgresAPIKeyRepository) update(ctx context.Context, key apikey.APIKey) error {
	query := `
		UPDATE api_keys SET
			name = :name,
			description = :description,
			scopes = :scopes,
			is_active = :is_active,
			expires_at = :expires_at,
			last_used_at = :last_used_at,
			updated_at = :updated_at
		WHERE id = :id AND tenant_id = :tenant_id`

	keyWithPGArray := toPersistence(key)

	result, err := r.db.NamedExecContext(ctx, query, keyWithPGArray)
	if err != nil {
		if pqErr, ok := err.(*pq.Error); ok && pqErr.Code == "23505" { // unique_violation on name
			return apikey.ErrAPIKeyInvalid().WithDetail("reason", "key name already exists for this tenant")
		}
		return errx.Wrap(err, "failed to update API key", errx.TypeInternal).
			WithDetail("key_id", key.ID)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected on update", errx.TypeInternal)
	}
	if rowsAffected == 0 {
		return apikey.ErrAPIKeyNotFound()
	}

	return nil
}

// FindByID busca una API key por su ID y tenant ID.
func (r *PostgresAPIKeyRepository) FindByID(ctx context.Context, id string, tenantID kernel.TenantID) (*apikey.APIKey, error) {
	var key apiKeyPersistence
	query := `SELECT * FROM api_keys WHERE id = $1 AND tenant_id = $2`
	err := r.db.GetContext(ctx, &key, query, id, tenantID.String())
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, apikey.ErrAPIKeyNotFound()
		}
		return nil, errx.Wrap(err, "failed to find API key by ID", errx.TypeInternal)
	}
	domainKey := toDomain(key)
	return &domainKey, nil
}

// FindByHash busca una API key por su hash SHA-256.
func (r *PostgresAPIKeyRepository) FindByHash(ctx context.Context, keyHash string) (*apikey.APIKey, error) {
	var key apiKeyPersistence
	query := `SELECT * FROM api_keys WHERE key_hash = $1`
	err := r.db.GetContext(ctx, &key, query, keyHash)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, apikey.ErrAPIKeyNotFound()
		}
		return nil, errx.Wrap(err, "failed to find API key by hash", errx.TypeInternal)
	}
	domainKey := toDomain(key)
	return &domainKey, nil
}

// FindByTenant busca todas las API keys para un tenant.
func (r *PostgresAPIKeyRepository) FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*apikey.APIKey, error) {
	var keys []apiKeyPersistence
	query := `SELECT * FROM api_keys WHERE tenant_id = $1 ORDER BY created_at DESC`
	err := r.db.SelectContext(ctx, &keys, query, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find API keys by tenant", errx.TypeInternal)
	}
	return toDomainSlice(keys), nil
}

// FindActiveByTenant busca todas las API keys activas de un tenant.
func (r *PostgresAPIKeyRepository) FindActiveByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*apikey.APIKey, error) {
	var keys []apiKeyPersistence
	query := `SELECT * FROM api_keys WHERE tenant_id = $1 AND is_active = true ORDER BY created_at DESC`
	err := r.db.SelectContext(ctx, &keys, query, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find active API keys by tenant", errx.TypeInternal)
	}
	return toDomainSlice(keys), nil
}

// FindByUser busca todas las API keys para un usuario específico.
func (r *PostgresAPIKeyRepository) FindByUser(ctx context.Context, userID kernel.UserID, tenantID kernel.TenantID) ([]*apikey.APIKey, error) {
	var keys []apiKeyPersistence
	query := `SELECT * FROM api_keys WHERE user_id = $1 AND tenant_id = $2 ORDER BY created_at DESC`
	err := r.db.SelectContext(ctx, &keys, query, userID.String(), tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find API keys by user", errx.TypeInternal)
	}
	return toDomainSlice(keys), nil
}

// Delete elimina una API key de la base de datos.
func (r *PostgresAPIKeyRepository) Delete(ctx context.Context, id string, tenantID kernel.TenantID) error {
	query := `DELETE FROM api_keys WHERE id = $1 AND tenant_id = $2`
	result, err := r.db.ExecContext(ctx, query, id, tenantID.String())
	if err != nil {
		return errx.Wrap(err, "failed to delete API key", errx.TypeInternal)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected on delete", errx.TypeInternal)
	}
	if rowsAffected == 0 {
		return apikey.ErrAPIKeyNotFound()
	}
	return nil
}

// UpdateLastUsed actualiza el timestamp de último uso de una key.
func (r *PostgresAPIKeyRepository) UpdateLastUsed(ctx context.Context, id string) error {
	query := `UPDATE api_keys SET last_used_at = NOW() WHERE id = $1`
	_, err := r.db.ExecContext(ctx, query, id)
	if err != nil {
		return errx.Wrap(err, "failed to update last used time for API key", errx.TypeInternal)
	}
	return nil
}

func (r *PostgresAPIKeyRepository) keyExists(ctx context.Context, id string) (bool, error) {
	var exists bool
	query := `SELECT EXISTS(SELECT 1 FROM api_keys WHERE id = $1)`
	err := r.db.GetContext(ctx, &exists, query, id)
	if err != nil {
		return false, errx.Wrap(err, "failed to check key existence", errx.TypeInternal)
	}
	return exists, nil
}

// Struct auxiliar para persistencia que maneja tipos de DB específicos.
type apiKeyPersistence struct {
	ID          string          `db:"id"`
	KeyHash     string          `db:"key_hash"`
	KeyPrefix   string          `db:"key_prefix"`
	TenantID    kernel.TenantID `db:"tenant_id"`
	UserID      *kernel.UserID  `db:"user_id"`
	Name        string          `db:"name"`
	Description sql.NullString  `db:"description"`
	Scopes      pq.StringArray  `db:"scopes"`
	IsActive    bool            `db:"is_active"`
	ExpiresAt   *time.Time      `db:"expires_at"`
	LastUsedAt  *time.Time      `db:"last_used_at"`
	CreatedAt   time.Time       `db:"created_at"`
	UpdatedAt   time.Time       `db:"updated_at"`
}

// toPersistence convierte el modelo de dominio a un modelo de persistencia.
func toPersistence(key apikey.APIKey) apiKeyPersistence {
	return apiKeyPersistence{
		ID:          key.ID,
		KeyHash:     key.KeyHash,
		KeyPrefix:   key.KeyPrefix,
		TenantID:    key.TenantID,
		UserID:      key.UserID,
		Name:        key.Name,
		Description: sql.NullString{String: key.Description, Valid: key.Description != ""},
		Scopes:      key.Scopes,
		IsActive:    key.IsActive,
		ExpiresAt:   key.ExpiresAt,
		LastUsedAt:  key.LastUsedAt,
		CreatedAt:   key.CreatedAt,
		UpdatedAt:   key.UpdatedAt,
	}
}

// toDomain convierte el modelo de persistencia al modelo de dominio.
func toDomain(p apiKeyPersistence) apikey.APIKey {
	return apikey.APIKey{
		ID:          p.ID,
		KeyHash:     p.KeyHash,
		KeyPrefix:   p.KeyPrefix,
		TenantID:    p.TenantID,
		UserID:      p.UserID,
		Name:        p.Name,
		Description: p.Description.String,
		Scopes:      p.Scopes,
		IsActive:    p.IsActive,
		ExpiresAt:   p.ExpiresAt,
		LastUsedAt:  p.LastUsedAt,
		CreatedAt:   p.CreatedAt,
		UpdatedAt:   p.UpdatedAt,
	}
}

// toDomainSlice convierte un slice de persistencia a un slice de dominio.
func toDomainSlice(pKeys []apiKeyPersistence) []*apikey.APIKey {
	domainKeys := make([]*apikey.APIKey, len(pKeys))
	for i, p := range pKeys {
		k := toDomain(p)
		domainKeys[i] = &k
	}
	return domainKeys
}
package apikey

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
)

type APIKey struct {
	ID          string          `db:"id" json:"id"`
	KeyHash     string          `db:"key_hash" json:"-"` // Never expose the hash
	KeyPrefix   string          `db:"key_prefix" json:"key_prefix"`
	TenantID    kernel.TenantID `db:"tenant_id" json:"tenant_id"`
	UserID      *kernel.UserID  `db:"user_id" json:"user_id,omitempty"`
	Name        string          `db:"name" json:"name"`
	Description string          `db:"description" json:"description,omitempty"`
	Scopes      []string        `db:"scopes" json:"scopes"`
	IsActive    bool            `db:"is_active" json:"is_active"`
	ExpiresAt   *time.Time      `db:"expires_at" json:"expires_at,omitempty"`
	LastUsedAt  *time.Time      `db:"last_used_at" json:"last_used_at,omitempty"`
	CreatedAt   time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`
}

func (k *APIKey) IsValid() bool {
	if !k.IsActive {
		return false
	}
	if k.ExpiresAt != nil && time.Now().After(*k.ExpiresAt) {
		return false
	}
	return true
}

func (k *APIKey) IsExpired() bool {
	return k.ExpiresAt != nil && time.Now().After(*k.ExpiresAt)
}

func (k *APIKey) HasScope(scope string) bool {
	for _, s := range k.Scopes {
		if s == scope || s == "*" {
			return true
		}
	}
	return false
}

func (k *APIKey) Revoke() {
	k.IsActive = false
	k.UpdatedAt = time.Now()
}

func (k *APIKey) UpdateLastUsed() {
	now := time.Now()
	k.LastUsedAt = &now
}

var (
	KeyPrefixLive string = "manifesto_live"
	KeyPrefixTest string = "manifesto_test"
	TokenLength   int    = 32
)

func InitAPIKeyConfig(livePrefix, testPrefix string, tokenLength int) {
	KeyPrefixLive = livePrefix
	KeyPrefixTest = testPrefix
	TokenLength = tokenLength
}

type GeneratedAPIKey struct {
	Key       string
	APIKey    APIKey
	KeyPrefix string
}

func GenerateAPIKey(prefix string) (*GeneratedAPIKey, error) {
	randomBytes := make([]byte, TokenLength)
	if _, err := rand.Read(randomBytes); err != nil {
		return nil, errx.Wrap(err, "failed to generate random key", errx.TypeInternal)
	}

	keySecret := hex.EncodeToString(randomBytes)
	fullKey := fmt.Sprintf("%s_%s", prefix, keySecret)

	return &GeneratedAPIKey{
		Key:       fullKey,
		KeyPrefix: fmt.Sprintf("%s_%s...", prefix, keySecret[:8]),
	}, nil
}

func HashAPIKey(key string) string {
	hash := sha256.Sum256([]byte(key))
	return hex.EncodeToString(hash[:])
}

func ValidateAPIKeyFormat(key string) bool {
	parts := strings.SplitN(key, "_", 3)
	if len(parts) != 3 {
		return false
	}

	return (fmt.Sprintf("%s_%s", parts[0], parts[1]) == KeyPrefixLive ||
		fmt.Sprintf("%s_%s", parts[0], parts[1]) == KeyPrefixTest) && len(parts[2]) == 64
}

type APIKeyDTO struct {
	ID          string          `json:"id"`
	KeyPrefix   string          `json:"key_prefix"`
	TenantID    kernel.TenantID `json:"tenant_id"`
	UserID      *kernel.UserID  `json:"user_id,omitempty"`
	Name        string          `json:"name"`
	Description string          `json:"description,omitempty"`
	Scopes      []string        `json:"scopes"`
	IsActive    bool            `json:"is_active"`
	ExpiresAt   *time.Time      `json:"expires_at,omitempty"`
	LastUsedAt  *time.Time      `json:"last_used_at,omitempty"`
	CreatedAt   time.Time       `json:"created_at"`
}

func (k *APIKey) ToDTO() APIKeyDTO {
	return APIKeyDTO{
		ID:          k.ID,
		KeyPrefix:   k.KeyPrefix,
		TenantID:    k.TenantID,
		UserID:      k.UserID,
		Name:        k.Name,
		Description: k.Description,
		Scopes:      k.Scopes,
		IsActive:    k.IsActive,
		ExpiresAt:   k.ExpiresAt,
		LastUsedAt:  k.LastUsedAt,
		CreatedAt:   k.CreatedAt,
	}
}

type CreateAPIKeyRequest struct {
	Name        string         `json:"name" validate:"required,min=3"`
	Description string         `json:"description"`
	Scopes      []string       `json:"scopes" validate:"required,min=1"`
	ExpiresIn   *int           `json:"expires_in"` // Days until expiration
	Environment string         `json:"environment" validate:"required,oneof=live test"`
	UserID      *kernel.UserID `json:"user_id"` // Optional: associate with specific user
}

type CreateAPIKeyResponse struct {
	APIKey    APIKeyDTO `json:"api_key"`
	SecretKey string    `json:"secret_key"` // Only shown once!
	Message   string    `json:"message"`
}

type UpdateAPIKeyRequest struct {
	Name        *string  `json:"name,omitempty" validate:"omitempty,min=3"`
	Description *string  `json:"description,omitempty"`
	Scopes      []string `json:"scopes,omitempty"`
	IsActive    *bool    `json:"is_active,omitempty"`
}

type APIKeyListResponse struct {
	APIKeys []APIKeyDTO `json:"api_keys"`
	Total   int         `json:"total"`
}

type RevokeAPIKeyRequest struct {
	Reason string `json:"reason"`
}

// ============================================================================
// Error Registry
// ============================================================================

var ErrRegistry = errx.NewRegistry("APIKEY")

var (
	CodeAPIKeyNotFound          = ErrRegistry.Register("NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "API key not found")
	CodeAPIKeyInvalid           = ErrRegistry.Register("INVALID", errx.TypeAuthorization, http.StatusUnauthorized, "Invalid API key")
	CodeAPIKeyExpired           = ErrRegistry.Register("EXPIRED", errx.TypeAuthorization, http.StatusUnauthorized, "API key expired")
	CodeAPIKeyRevoked           = ErrRegistry.Register("REVOKED", errx.TypeAuthorization, http.StatusUnauthorized, "API key revoked")
	CodeAPIKeyInsufficientScope = ErrRegistry.Register("INSUFFICIENT_SCOPE", errx.TypeAuthorization, http.StatusForbidden, "API key does not have required scope")
)

func ErrAPIKeyNotFound() *errx.Error {
	return ErrRegistry.New(CodeAPIKeyNotFound)
}

func ErrAPIKeyInvalid() *errx.Error {
	return ErrRegistry.New(CodeAPIKeyInvalid)
}

func ErrAPIKeyExpired() *errx.Error {
	return ErrRegistry.New(CodeAPIKeyExpired)
}

func ErrAPIKeyRevoked() *errx.Error {
	return ErrRegistry.New(CodeAPIKeyRevoked)
}

func ErrAPIKeyInsufficientScope() *errx.Error {
	return ErrRegistry.New(CodeAPIKeyInsufficientScope)
}
package invitationapi

import (
	"github.com/Abraxas-365/manifesto/pkg/iam"
	"github.com/Abraxas-365/manifesto/pkg/iam/auth"
	"github.com/Abraxas-365/manifesto/pkg/iam/invitation"
	"github.com/Abraxas-365/manifesto/pkg/iam/invitation/invitationsrv"
	"github.com/gofiber/fiber/v2"
)

// InvitationHandlers maneja las rutas de invitaciones con Fiber
type InvitationHandlers struct {
	service *invitationsrv.InvitationService
}

// NewInvitationHandlers crea un nuevo handler de invitaciones
func NewInvitationHandlers(service *invitationsrv.InvitationService) *InvitationHandlers {
	return &InvitationHandlers{
		service: service,
	}
}

// RegisterRoutes registra las rutas de invitaciones en Fiber
func (h *InvitationHandlers) RegisterRoutes(router fiber.Router, authMiddleware *auth.UnifiedAuthMiddleware) {
	invitations := router.Group("/invitations", authMiddleware.Authenticate())

	// Protected routes
	invitations.Post("/", h.CreateInvitation)
	invitations.Get("/", h.GetTenantInvitations)
	invitations.Get("/pending", h.GetPendingInvitations)
	invitations.Get("/:id", h.GetInvitationByID)
	invitations.Delete("/:id", h.DeleteInvitation)
	invitations.Post("/:id/revoke", h.RevokeInvitation)

	// Public routes
	public := router.Group("/invitations/public")
	public.Get("/validate", h.ValidateInvitationToken)
	public.Get("/token/:token", h.GetInvitationByToken)
}

// CreateInvitation crea una nueva invitación
func (h *InvitationHandlers) CreateInvitation(c *fiber.Ctx) error {
	authContext, ok := auth.GetAuthContext(c)
	if !ok {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "Unauthorized",
		})
	}

	var req invitation.CreateInvitationRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "Invalid request body",
		})
	}

	if authContext.UserID == nil {
		return iam.ErrUnauthorized()
	}

	// Crear invitación
	inv, err := h.service.CreateInvitation(c.Context(), authContext.TenantID, *authContext.UserID, req)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	return c.Status(fiber.StatusCreated).JSON(inv.ToDTO())
}

// GetTenantInvitations obtiene todas las invitaciones del tenant
func (h *InvitationHandlers) GetTenantInvitations(c *fiber.Ctx) error {
	authContext, ok := auth.GetAuthContext(c)
	if !ok {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "Unauthorized",
		})
	}

	invitations, err := h.service.GetTenantInvitations(c.Context(), authContext.TenantID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	return c.JSON(invitations.ToDTO())
}

// GetPendingInvitations obtiene invitaciones pendientes del tenant
func (h *InvitationHandlers) GetPendingInvitations(c *fiber.Ctx) error {
	authContext, ok := auth.GetAuthContext(c)
	if !ok {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "Unauthorized",
		})
	}

	invitations, err := h.service.GetPendingInvitations(c.Context(), authContext.TenantID)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	return c.JSON(invitations.ToDTO())
}

// GetInvitationByID obtiene una invitación por ID
func (h *InvitationHandlers) GetInvitationByID(c *fiber.Ctx) error {
	authContext, ok := auth.GetAuthContext(c)
	if !ok {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "Unauthorized",
		})
	}

	invitationID := c.Params("id")
	if invitationID == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "invitation_id is required",
		})
	}

	invitation, err := h.service.GetInvitationByID(c.Context(), invitationID, authContext.TenantID)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	return c.JSON(invitation.ToDTO())
}

// GetInvitationByToken obtiene una invitación por token (público)
func (h *InvitationHandlers) GetInvitationByToken(c *fiber.Ctx) error {
	token := c.Params("token")
	if token == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "token is required",
		})
	}

	invitation, err := h.service.GetInvitationByToken(c.Context(), token)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	return c.JSON(invitation.ToDTO())
}

// ValidateInvitationToken valida un token de invitación (público)
func (h *InvitationHandlers) ValidateInvitationToken(c *fiber.Ctx) error {
	token := c.Query("token")
	if token == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "token is required",
		})
	}

	response, err := h.service.ValidateInvitationToken(c.Context(), token)
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	return c.JSON(response)
}

// RevokeInvitation revoca una invitación
func (h *InvitationHandlers) RevokeInvitation(c *fiber.Ctx) error {
	authContext, ok := auth.GetAuthContext(c)
	if !ok {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "Unauthorized",
		})
	}

	invitationID := c.Params("id")
	if invitationID == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "invitation_id is required",
		})
	}

	err := h.service.RevokeInvitation(c.Context(), invitationID, authContext.TenantID)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	return c.JSON(fiber.Map{
		"message": "Invitation revoked successfully",
	})
}

// DeleteInvitation elimina una invitación
func (h *InvitationHandlers) DeleteInvitation(c *fiber.Ctx) error {
	authContext, ok := auth.GetAuthContext(c)
	if !ok {
		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"error": "Unauthorized",
		})
	}

	invitationID := c.Params("id")
	if invitationID == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "invitation_id is required",
		})
	}

	err := h.service.DeleteInvitation(c.Context(), invitationID, authContext.TenantID)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	return c.JSON(fiber.Map{
		"message": "Invitation deleted successfully",
	})
}
package invitation

import (
	"context"

	"github.com/Abraxas-365/manifesto/pkg/kernel"
)

// InvitationRepository define el contrato para la persistencia de invitaciones
type InvitationRepository interface {
	// FindByID busca una invitación por ID
	FindByID(ctx context.Context, id string) (*Invitation, error)

	// FindByToken busca una invitación por token
	FindByToken(ctx context.Context, token string) (*Invitation, error)

	// FindByEmail busca invitaciones por email
	FindByEmail(ctx context.Context, email string, tenantID kernel.TenantID) ([]*Invitation, error)

	// FindPendingByEmail busca invitaciones pendientes para un email en un tenant
	FindPendingByEmail(ctx context.Context, email string, tenantID kernel.TenantID) (*Invitation, error)

	// FindByTenant busca todas las invitaciones de un tenant
	FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*Invitation, error)

	// FindPendingByTenant busca invitaciones pendientes de un tenant
	FindPendingByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*Invitation, error)

	// FindExpired busca invitaciones expiradas
	FindExpired(ctx context.Context) ([]*Invitation, error)

	// Save guarda o actualiza una invitación
	Save(ctx context.Context, inv Invitation) error

	// Delete elimina una invitación
	Delete(ctx context.Context, id string) error

	// ExistsPendingForEmail verifica si existe una invitación pendiente para un email
	ExistsPendingForEmail(ctx context.Context, email string, tenantID kernel.TenantID) (bool, error)
}
// pkg/iam/invitation/invitationsrv/service.go
package invitationsrv

import (
	"context"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/config"
	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam/invitation"
	"github.com/Abraxas-365/manifesto/pkg/iam/scopes"
	"github.com/Abraxas-365/manifesto/pkg/iam/tenant"
	"github.com/Abraxas-365/manifesto/pkg/iam/user"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/google/uuid"
)

// InvitationService proporciona operaciones de negocio para invitaciones
type InvitationService struct {
	invitationRepo invitation.InvitationRepository
	userRepo       user.UserRepository
	tenantRepo     tenant.TenantRepository
	config         *config.InvitationConfig
}

// NewInvitationService crea una nueva instancia del servicio de invitaciones
func NewInvitationService(
	invitationRepo invitation.InvitationRepository,
	userRepo user.UserRepository,
	tenantRepo tenant.TenantRepository,
	cfg *config.InvitationConfig,
) *InvitationService {
	return &InvitationService{
		invitationRepo: invitationRepo,
		userRepo:       userRepo,
		tenantRepo:     tenantRepo,
		config:         cfg,
	}
}

// CreateInvitation crea una nueva invitación
func (s *InvitationService) CreateInvitation(ctx context.Context, tenantID kernel.TenantID, invitedBy kernel.UserID, req invitation.CreateInvitationRequest) (*invitation.Invitation, error) {
	// Verificar que el tenant existe
	tenantEntity, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	// Verificar que el tenant está activo
	if !tenantEntity.IsActive() {
		return nil, tenant.ErrTenantSuspended()
	}

	// Verificar que el usuario que invita existe
	inviterUser, err := s.userRepo.FindByID(ctx, invitedBy, tenantID)
	if err != nil {
		return nil, user.ErrUserNotFound()
	}

	// Verificar que el invitador tiene permisos (admin o users:invite)
	if !inviterUser.IsAdmin() && !inviterUser.HasScope(scopes.ScopeUsersInvite) {
		return nil, errx.New("insufficient permissions to invite users", errx.TypeAuthorization).
			WithDetail("required_scope", scopes.ScopeUsersInvite)
	}

	// Verificar que el usuario no existe ya en el tenant
	existingUser, err := s.userRepo.FindByEmail(ctx, req.Email, tenantID)
	if err == nil && existingUser != nil {
		return nil, invitation.ErrUserAlreadyExists().WithDetail("email", req.Email)
	}

	// Verificar que no existe una invitación pendiente para este email
	exists, err := s.invitationRepo.ExistsPendingForEmail(ctx, req.Email, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to check pending invitation", errx.TypeInternal)
	}
	if exists {
		return nil, invitation.ErrInvitationAlreadyExists().WithDetail("email", req.Email)
	}

	// Determinar scopes
	resolvedScopes, err := s.resolveScopes(req)
	if err != nil {
		return nil, err
	}

	// Validar scopes
	if err := s.validateScopes(resolvedScopes); err != nil {
		return nil, err
	}

	// Generar token único usando configuración
	token, err := invitation.GenerateInvitationToken(s.config.TokenByteLength)
	if err != nil {
		return nil, errx.Wrap(err, "failed to generate invitation token", errx.TypeInternal)
	}

	// Calcular fecha de expiración usando configuración
	expiresIn := s.config.DefaultExpirationDays
	if req.ExpiresIn != nil && *req.ExpiresIn > 0 {
		expiresIn = *req.ExpiresIn
	}
	expiresAt := invitation.CalculateExpirationDate(expiresIn, s.config.DefaultExpirationDays)

	// Crear invitación
	newInvitation := &invitation.Invitation{
		ID:        uuid.NewString(),
		TenantID:  tenantID,
		Email:     req.Email,
		Token:     token,
		Scopes:    resolvedScopes,
		Status:    invitation.InvitationStatusPending,
		InvitedBy: invitedBy,
		ExpiresAt: expiresAt,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// Guardar invitación
	if err := s.invitationRepo.Save(ctx, *newInvitation); err != nil {
		return nil, errx.Wrap(err, "failed to save invitation", errx.TypeInternal)
	}

	// TODO: Aquí deberías enviar un email con el link de invitación
	// Por ejemplo: https://yourapp.com/accept-invitation?token={token}

	return newInvitation, nil
}

// GetInvitationByID obtiene una invitación por ID
func (s *InvitationService) GetInvitationByID(ctx context.Context, invitationID string, tenantID kernel.TenantID) (*invitation.InvitationResponse, error) {
	inv, err := s.invitationRepo.FindByID(ctx, invitationID)
	if err != nil {
		return nil, invitation.ErrInvitationNotFound()
	}

	// Verificar que la invitación pertenece al tenant
	if inv.TenantID != tenantID {
		return nil, invitation.ErrInvitationNotFound()
	}

	return s.buildInvitationResponse(inv), nil
}

// GetInvitationByToken obtiene una invitación por token
func (s *InvitationService) GetInvitationByToken(ctx context.Context, token string) (*invitation.InvitationResponse, error) {
	inv, err := s.invitationRepo.FindByToken(ctx, token)
	if err != nil {
		return nil, invitation.ErrInvitationNotFound()
	}

	return s.buildInvitationResponse(inv), nil
}

// ValidateInvitationToken valida un token de invitación sin aceptarlo
func (s *InvitationService) ValidateInvitationToken(ctx context.Context, token string) (*invitation.ValidateInvitationResponse, error) {
	inv, err := s.invitationRepo.FindByToken(ctx, token)
	if err != nil {
		return &invitation.ValidateInvitationResponse{
			Valid:   false,
			Message: "Invitación no encontrada",
		}, nil
	}

	if !inv.CanBeAccepted() {
		message := "Invitación inválida"
		if inv.IsExpired() {
			message = "Invitación expirada"
		} else if inv.Status == invitation.InvitationStatusAccepted {
			message = "Invitación ya aceptada"
		} else if inv.Status == invitation.InvitationStatusRevoked {
			message = "Invitación revocada"
		}

		return &invitation.ValidateInvitationResponse{
			Valid:   false,
			Message: message,
		}, nil
	}

	invDTO := inv.ToDTO()
	return &invitation.ValidateInvitationResponse{
		Valid:      true,
		Invitation: &invDTO,
		Message:    "Invitación válida",
	}, nil
}

// GetTenantInvitations obtiene todas las invitaciones de un tenant
func (s *InvitationService) GetTenantInvitations(ctx context.Context, tenantID kernel.TenantID) (*invitation.InvitationListResponse, error) {
	// Verificar que el tenant existe
	_, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	invitations, err := s.invitationRepo.FindByTenant(ctx, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get tenant invitations", errx.TypeInternal)
	}

	var responses []invitation.InvitationResponse
	for _, inv := range invitations {
		responses = append(responses, *s.buildInvitationResponse(inv))
	}

	return &invitation.InvitationListResponse{
		Invitations: responses,
		Total:       len(responses),
	}, nil
}

// GetPendingInvitations obtiene invitaciones pendientes de un tenant
func (s *InvitationService) GetPendingInvitations(ctx context.Context, tenantID kernel.TenantID) (*invitation.InvitationListResponse, error) {
	// Verificar que el tenant existe
	_, err := s.tenantRepo.FindByID(ctx, tenantID)
	if err != nil {
		return nil, tenant.ErrTenantNotFound()
	}

	invitations, err := s.invitationRepo.FindPendingByTenant(ctx, tenantID)
	if err != nil {
		return nil, errx.Wrap(err, "failed to get pending invitations", errx.TypeInternal)
	}

	var responses []invitation.InvitationResponse
	for _, inv := range invitations {
		responses = append(responses, *s.buildInvitationResponse(inv))
	}

	return &invitation.InvitationListResponse{
		Invitations: responses,
		Total:       len(responses),
	}, nil
}

// RevokeInvitation revoca una invitación
func (s *InvitationService) RevokeInvitation(ctx context.Context, invitationID string, tenantID kernel.TenantID) error {
	inv, err := s.invitationRepo.FindByID(ctx, invitationID)
	if err != nil {
		return invitation.ErrInvitationNotFound()
	}

	// Verificar que la invitación pertenece al tenant
	if inv.TenantID != tenantID {
		return invitation.ErrInvitationNotFound()
	}

	// Revocar invitación
	if err := inv.Revoke(); err != nil {
		return err
	}

	// Guardar cambios
	return s.invitationRepo.Save(ctx, *inv)
}

// DeleteInvitation elimina una invitación
func (s *InvitationService) DeleteInvitation(ctx context.Context, invitationID string, tenantID kernel.TenantID) error {
	inv, err := s.invitationRepo.FindByID(ctx, invitationID)
	if err != nil {
		return invitation.ErrInvitationNotFound()
	}

	// Verificar que la invitación pertenece al tenant
	if inv.TenantID != tenantID {
		return invitation.ErrInvitationNotFound()
	}

	// Solo se pueden eliminar invitaciones que no han sido aceptadas
	if inv.Status == invitation.InvitationStatusAccepted {
		return errx.New("cannot delete accepted invitation", errx.TypeBusiness)
	}

	return s.invitationRepo.Delete(ctx, invitationID)
}

// CleanupExpiredInvitations marca invitaciones expiradas
// Este método debería ser llamado por un cronjob
func (s *InvitationService) CleanupExpiredInvitations(ctx context.Context) (int, error) {
	expiredInvitations, err := s.invitationRepo.FindExpired(ctx)
	if err != nil {
		return 0, errx.Wrap(err, "failed to find expired invitations", errx.TypeInternal)
	}

	count := 0
	for _, inv := range expiredInvitations {
		inv.MarkAsExpired()
		if err := s.invitationRepo.Save(ctx, *inv); err != nil {
			// Log error but continue
			continue
		}
		count++
	}

	return count, nil
}

// GetAvailableScopeTemplates retorna las plantillas de scopes disponibles
func (s *InvitationService) GetAvailableScopeTemplates() []string {
	templates := make([]string, 0, len(scopes.ScopeGroups))
	for template := range scopes.ScopeGroups {
		templates = append(templates, template)
	}
	return templates
}

// ============================================================================
// Private Helper Methods
// ============================================================================

// resolveScopes determina los scopes finales basándose en la request
func (s *InvitationService) resolveScopes(req invitation.CreateInvitationRequest) ([]string, error) {
	// Si se proporcionan scopes directamente, usarlos
	if len(req.Scopes) > 0 {
		return req.Scopes, nil
	}

	// Si se proporciona un template, expandirlo
	if req.ScopeTemplate != nil && *req.ScopeTemplate != "" {
		scopeList := scopes.GetScopesByGroup(*req.ScopeTemplate)
		if len(scopeList) == 0 {
			return nil, invitation.ErrInvalidScopeTemplate().
				WithDetail("template", *req.ScopeTemplate).
				WithDetail("available_templates", s.GetAvailableScopeTemplates())
		}
		return scopeList, nil
	}

	// Default: usar template "viewer" o scopes básicos
	defaultScopes := scopes.GetScopesByGroup("viewer")
	return defaultScopes, nil
}

// validateScopes valida que los scopes sean válidos
func (s *InvitationService) validateScopes(scopesList []string) error {
	if len(scopesList) == 0 {
		return invitation.ErrInvalidScopes().WithDetail("reason", "at least one scope is required")
	}

	// Validar cada scope
	invalidScopes := []string{}
	for _, scope := range scopesList {
		if !scopes.ValidateScope(scope) {
			invalidScopes = append(invalidScopes, scope)
		}
	}

	if len(invalidScopes) > 0 {
		return invitation.ErrInvalidScopes().
			WithDetail("invalid_scopes", invalidScopes).
			WithDetail("hint", "Use GetAvailableScopeTemplates() to see valid options")
	}

	return nil
}

// buildInvitationResponse construye una respuesta completa
func (s *InvitationService) buildInvitationResponse(inv *invitation.Invitation) *invitation.InvitationResponse {
	return &invitation.InvitationResponse{
		Invitation:     *inv,
		ScopeTemplates: s.GetAvailableScopeTemplates(),
	}
}
package invitationinfra

import (
	"context"
	"database/sql"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/iam/invitation"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

// PostgresInvitationRepository implementación de PostgreSQL para InvitationRepository
type PostgresInvitationRepository struct {
	db *sqlx.DB
}

// NewPostgresInvitationRepository crea una nueva instancia del repositorio de invitaciones
func NewPostgresInvitationRepository(db *sqlx.DB) invitation.InvitationRepository {
	return &PostgresInvitationRepository{
		db: db,
	}
}

// getExecutor returns transaction if present in context, otherwise returns db
func (r *PostgresInvitationRepository) getExecutor(ctx context.Context) sqlx.ExtContext {
	if tx, ok := ctx.Value("db_tx").(*sqlx.Tx); ok {
		return tx
	}
	return r.db
}

// FindByID busca una invitación por ID
func (r *PostgresInvitationRepository) FindByID(ctx context.Context, id string) (*invitation.Invitation, error) {
	executor := r.getExecutor(ctx)

	query := `
		SELECT
			id, tenant_id, email, token, scopes, status, invited_by,
			expires_at, accepted_at, accepted_by, created_at, updated_at
		FROM invitations
		WHERE id = $1`

	var inv invitation.Invitation
	err := sqlx.GetContext(ctx, executor, &inv, query, id)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, invitation.ErrInvitationNotFound().WithDetail("invitation_id", id)
		}
		return nil, errx.Wrap(err, "failed to find invitation by id", errx.TypeInternal).
			WithDetail("invitation_id", id)
	}

	return &inv, nil
}

// FindByToken busca una invitación por token
func (r *PostgresInvitationRepository) FindByToken(ctx context.Context, token string) (*invitation.Invitation, error) {
	executor := r.getExecutor(ctx)

	query := `
		SELECT
			id, tenant_id, email, token, scopes, status, invited_by,
			expires_at, accepted_at, accepted_by, created_at, updated_at
		FROM invitations
		WHERE token = $1`

	var inv invitation.Invitation
	err := sqlx.GetContext(ctx, executor, &inv, query, token)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, invitation.ErrInvitationNotFound().WithDetail("token", token)
		}
		return nil, errx.Wrap(err, "failed to find invitation by token", errx.TypeInternal)
	}

	return &inv, nil
}

// FindByEmail busca invitaciones por email
func (r *PostgresInvitationRepository) FindByEmail(ctx context.Context, email string, tenantID kernel.TenantID) ([]*invitation.Invitation, error) {
	executor := r.getExecutor(ctx)

	query := `
		SELECT
			id, tenant_id, email, token, scopes, status, invited_by,
			expires_at, accepted_at, accepted_by, created_at, updated_at
		FROM invitations
		WHERE email = $1 AND tenant_id = $2
		ORDER BY created_at DESC`

	var invitations []invitation.Invitation
	err := sqlx.SelectContext(ctx, executor, &invitations, query, email, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find invitations by email", errx.TypeInternal).
			WithDetail("email", email)
	}

	// Convertir a slice de punteros
	result := make([]*invitation.Invitation, len(invitations))
	for i := range invitations {
		result[i] = &invitations[i]
	}

	return result, nil
}

// FindPendingByEmail busca invitaciones pendientes para un email en un tenant
func (r *PostgresInvitationRepository) FindPendingByEmail(ctx context.Context, email string, tenantID kernel.TenantID) (*invitation.Invitation, error) {
	executor := r.getExecutor(ctx)

	query := `
		SELECT
			id, tenant_id, email, token, scopes, status, invited_by,
			expires_at, accepted_at, accepted_by, created_at, updated_at
		FROM invitations
		WHERE email = $1 AND tenant_id = $2 AND status = 'PENDING' AND expires_at > NOW()
		ORDER BY created_at DESC
		LIMIT 1`

	var inv invitation.Invitation
	err := sqlx.GetContext(ctx, executor, &inv, query, email, tenantID.String())
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, invitation.ErrInvitationNotFound().WithDetail("email", email)
		}
		return nil, errx.Wrap(err, "failed to find pending invitation", errx.TypeInternal).
			WithDetail("email", email)
	}

	return &inv, nil
}

// FindByTenant busca todas las invitaciones de un tenant
func (r *PostgresInvitationRepository) FindByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*invitation.Invitation, error) {
	executor := r.getExecutor(ctx)

	query := `
		SELECT
			id, tenant_id, email, token, scopes, status, invited_by,
			expires_at, accepted_at, accepted_by, created_at, updated_at
		FROM invitations
		WHERE tenant_id = $1
		ORDER BY created_at DESC`

	var invitations []invitation.Invitation
	err := sqlx.SelectContext(ctx, executor, &invitations, query, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find invitations by tenant", errx.TypeInternal).
			WithDetail("tenant_id", tenantID.String())
	}

	// Convertir a slice de punteros
	result := make([]*invitation.Invitation, len(invitations))
	for i := range invitations {
		result[i] = &invitations[i]
	}

	return result, nil
}

// FindPendingByTenant busca invitaciones pendientes de un tenant
func (r *PostgresInvitationRepository) FindPendingByTenant(ctx context.Context, tenantID kernel.TenantID) ([]*invitation.Invitation, error) {
	executor := r.getExecutor(ctx)

	query := `
		SELECT
			id, tenant_id, email, token, scopes, status, invited_by,
			expires_at, accepted_at, accepted_by, created_at, updated_at
		FROM invitations
		WHERE tenant_id = $1 AND status = 'PENDING' AND expires_at > NOW()
		ORDER BY created_at DESC`

	var invitations []invitation.Invitation
	err := sqlx.SelectContext(ctx, executor, &invitations, query, tenantID.String())
	if err != nil {
		return nil, errx.Wrap(err, "failed to find pending invitations", errx.TypeInternal).
			WithDetail("tenant_id", tenantID.String())
	}

	// Convertir a slice de punteros
	result := make([]*invitation.Invitation, len(invitations))
	for i := range invitations {
		result[i] = &invitations[i]
	}

	return result, nil
}

// FindExpired busca invitaciones expiradas
func (r *PostgresInvitationRepository) FindExpired(ctx context.Context) ([]*invitation.Invitation, error) {
	executor := r.getExecutor(ctx)

	query := `
		SELECT
			id, tenant_id, email, token, scopes, status, invited_by,
			expires_at, accepted_at, accepted_by, created_at, updated_at
		FROM invitations
		WHERE status = 'PENDING' AND expires_at < NOW()`

	var invitations []invitation.Invitation
	err := sqlx.SelectContext(ctx, executor, &invitations, query)
	if err != nil {
		return nil, errx.Wrap(err, "failed to find expired invitations", errx.TypeInternal)
	}

	// Convertir a slice de punteros
	result := make([]*invitation.Invitation, len(invitations))
	for i := range invitations {
		result[i] = &invitations[i]
	}

	return result, nil
}

// Save guarda o actualiza una invitación
func (r *PostgresInvitationRepository) Save(ctx context.Context, inv invitation.Invitation) error {
	// Verificar si la invitación ya existe
	exists, err := r.invitationExists(ctx, inv.ID)
	if err != nil {
		return errx.Wrap(err, "failed to check invitation existence", errx.TypeInternal)
	}

	if exists {
		return r.update(ctx, inv)
	}
	return r.create(ctx, inv)
}

// create crea una nueva invitación
func (r *PostgresInvitationRepository) create(ctx context.Context, inv invitation.Invitation) error {
	executor := r.getExecutor(ctx)

	query := `
		INSERT INTO invitations (
			id, tenant_id, email, token, scopes, status, invited_by,
			expires_at, accepted_at, accepted_by, created_at, updated_at
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
		)`

	_, err := executor.ExecContext(ctx, query,
		inv.ID,
		inv.TenantID,
		inv.Email,
		inv.Token,
		pq.Array(inv.Scopes),
		inv.Status,
		inv.InvitedBy,
		inv.ExpiresAt,
		inv.AcceptedAt,
		inv.AcceptedBy,
		inv.CreatedAt,
		inv.UpdatedAt,
	)

	if err != nil {
		// Verificar violación de constraint único
		if pqErr, ok := err.(*pq.Error); ok {
			if pqErr.Code == "23505" {
				return invitation.ErrInvitationAlreadyExists().
					WithDetail("email", inv.Email)
			}
		}
		return errx.Wrap(err, "failed to create invitation", errx.TypeInternal).
			WithDetail("invitation_id", inv.ID)
	}

	return nil
}

// update actualiza una invitación existente
func (r *PostgresInvitationRepository) update(ctx context.Context, inv invitation.Invitation) error {
	executor := r.getExecutor(ctx)

	query := `
		UPDATE invitations SET
			email = $1,
			status = $2,
			scopes = $3,
			expires_at = $4,
			accepted_at = $5,
			accepted_by = $6,
			updated_at = $7
		WHERE id = $8`

	result, err := executor.ExecContext(ctx, query,
		inv.Email,
		inv.Status,
		pq.Array(inv.Scopes),
		inv.ExpiresAt,
		inv.AcceptedAt,
		inv.AcceptedBy,
		inv.UpdatedAt,
		inv.ID,
	)

	if err != nil {
		return errx.Wrap(err, "failed to update invitation", errx.TypeInternal).
			WithDetail("invitation_id", inv.ID)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return invitation.ErrInvitationNotFound().WithDetail("invitation_id", inv.ID)
	}

	return nil
}

// Delete elimina una invitación
func (r *PostgresInvitationRepository) Delete(ctx context.Context, id string) error {
	executor := r.getExecutor(ctx)

	query := `DELETE FROM invitations WHERE id = $1`

	result, err := executor.ExecContext(ctx, query, id)
	if err != nil {
		return errx.Wrap(err, "failed to delete invitation", errx.TypeInternal).
			WithDetail("invitation_id", id)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return errx.Wrap(err, "failed to get rows affected", errx.TypeInternal)
	}

	if rowsAffected == 0 {
		return invitation.ErrInvitationNotFound().WithDetail("invitation_id", id)
	}

	return nil
}

// ExistsPendingForEmail verifica si existe una invitación pendiente para un email
func (r *PostgresInvitationRepository) ExistsPendingForEmail(ctx context.Context, email string, tenantID kernel.TenantID) (bool, error) {
	executor := r.getExecutor(ctx)

	query := `
		SELECT EXISTS(
			SELECT 1 FROM invitations
			WHERE email = $1 AND tenant_id = $2 AND status = 'PENDING' AND expires_at > NOW()
		)`

	var exists bool
	err := sqlx.GetContext(ctx, executor, &exists, query, email, tenantID.String())
	if err != nil {
		return false, errx.Wrap(err, "failed to check pending invitation existence", errx.TypeInternal).
			WithDetail("email", email)
	}

	return exists, nil
}

// invitationExists verifica si una invitación existe por ID
func (r *PostgresInvitationRepository) invitationExists(ctx context.Context, id string) (bool, error) {
	executor := r.getExecutor(ctx)

	query := `SELECT EXISTS(SELECT 1 FROM invitations WHERE id = $1)`

	var exists bool
	err := sqlx.GetContext(ctx, executor, &exists, query, id)
	if err != nil {
		return false, errx.Wrap(err, "failed to check invitation existence", errx.TypeInternal).
			WithDetail("invitation_id", id)
	}

	return exists, nil
}
package invitation

import (
	"crypto/rand"
	"encoding/hex"
	"net/http"
	"time"

	"github.com/Abraxas-365/manifesto/pkg/errx"
	"github.com/Abraxas-365/manifesto/pkg/kernel"
	"slices"
)

// ============================================================================
// Invitation Entity
// ============================================================================

// InvitationStatus define los posibles estados de una invitación
type InvitationStatus string

const (
	InvitationStatusPending  InvitationStatus = "PENDING"
	InvitationStatusAccepted InvitationStatus = "ACCEPTED"
	InvitationStatusExpired  InvitationStatus = "EXPIRED"
	InvitationStatusRevoked  InvitationStatus = "REVOKED"
)

// Invitation es la entidad que representa una invitación de usuario
type Invitation struct {
	ID         string           `db:"id" json:"id"`
	TenantID   kernel.TenantID  `db:"tenant_id" json:"tenant_id"`
	Email      string           `db:"email" json:"email"`
	Token      string           `db:"token" json:"token"`
	Scopes     []string         `db:"scopes" json:"scopes"` // ✅ Changed from RoleID
	Status     InvitationStatus `db:"status" json:"status"`
	InvitedBy  kernel.UserID    `db:"invited_by" json:"invited_by"`
	ExpiresAt  time.Time        `db:"expires_at" json:"expires_at"`
	AcceptedAt *time.Time       `db:"accepted_at" json:"accepted_at,omitempty"`
	AcceptedBy *kernel.UserID   `db:"accepted_by" json:"accepted_by,omitempty"`
	CreatedAt  time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt  time.Time        `db:"updated_at" json:"updated_at"`
}

// ============================================================================
// Domain Methods
// ============================================================================

// ============================================================================
// Getter Methods (para interfaces compatibles con auth)
// ============================================================================

// GetID retorna el ID de la invitación
func (i *Invitation) GetID() string {
	return i.ID
}

// GetTenantID retorna el TenantID de la invitación
func (i *Invitation) GetTenantID() kernel.TenantID {
	return i.TenantID
}

// GetEmail retorna el email de la invitación
func (i *Invitation) GetEmail() string {
	return i.Email
}

// GetScopes retorna los scopes de la invitación
func (i *Invitation) GetScopes() []string {
	return i.Scopes
}

// IsValid verifica si la invitación es válida
func (i *Invitation) IsValid() bool {
	return i.Status == InvitationStatusPending && time.Now().Before(i.ExpiresAt)
}

// IsExpired verifica si la invitación ha expirado
func (i *Invitation) IsExpired() bool {
	return time.Now().After(i.ExpiresAt)
}

// CanBeAccepted verifica si la invitación puede ser aceptada
func (i *Invitation) CanBeAccepted() bool {
	return i.Status == InvitationStatusPending && !i.IsExpired()
}

// Accept marca la invitación como aceptada
func (i *Invitation) Accept(userID kernel.UserID) error {
	if !i.CanBeAccepted() {
		if i.IsExpired() {
			return ErrInvitationExpired()
		}
		return ErrInvitationInvalid().WithDetail("status", string(i.Status))
	}

	now := time.Now()
	i.Status = InvitationStatusAccepted
	i.AcceptedAt = &now
	i.AcceptedBy = &userID
	i.UpdatedAt = now

	return nil
}

// Revoke revoca la invitación
func (i *Invitation) Revoke() error {
	if i.Status == InvitationStatusAccepted {
		return ErrInvitationAlreadyAccepted()
	}
	if i.Status == InvitationStatusRevoked {
		return ErrInvitationAlreadyRevoked()
	}

	i.Status = InvitationStatusRevoked
	i.UpdatedAt = time.Now()
	return nil
}

// MarkAsExpired marca la invitación como expirada
func (i *Invitation) MarkAsExpired() {
	if i.Status == InvitationStatusPending && i.IsExpired() {
		i.Status = InvitationStatusExpired
		i.UpdatedAt = time.Now()
	}
}

// HasScope verifica si la invitación incluye un scope específico
func (i *Invitation) HasScope(scope string) bool {
	for _, s := range i.Scopes {
		if s == scope || s == "*" {
			return true
		}
	}
	return false
}

// HasAnyScope verifica si la invitación incluye alguno de los scopes
func (i *Invitation) HasAnyScope(scopes ...string) bool {
	return slices.ContainsFunc(scopes, i.HasScope)
}

// ============================================================================
// DTOs
// ============================================================================

// InvitationDetailsDTO contiene información básica de una invitación
type InvitationDetailsDTO struct {
	ID         string           `json:"id"`
	TenantID   kernel.TenantID  `json:"tenant_id"`
	Email      string           `json:"email"`
	Status     InvitationStatus `json:"status"`
	Scopes     []string         `json:"scopes"`
	ExpiresAt  time.Time        `json:"expires_at"`
	AcceptedAt *time.Time       `json:"accepted_at,omitempty"`
	CreatedAt  time.Time        `json:"created_at"`
}

// ToDTO convierte la entidad Invitation a InvitationDetailsDTO
func (i *Invitation) ToDTO() InvitationDetailsDTO {
	return InvitationDetailsDTO{
		ID:         i.ID,
		TenantID:   i.TenantID,
		Email:      i.Email,
		Status:     i.Status,
		Scopes:     i.Scopes,
		ExpiresAt:  i.ExpiresAt,
		AcceptedAt: i.AcceptedAt,
		CreatedAt:  i.CreatedAt,
	}
}

// ============================================================================
// Service DTOs - Para operaciones de la capa de servicio
// ============================================================================

// CreateInvitationRequest representa la petición para crear una invitación
type CreateInvitationRequest struct {
	Email         string   `json:"email" validate:"required,email"`
	Scopes        []string `json:"scopes,omitempty"`         // ✅ Direct scopes
	ScopeTemplate *string  `json:"scope_template,omitempty"` // ✅ Optional: "recruiter", "hiring_manager", etc
	ExpiresIn     *int     `json:"expires_in,omitempty"`     // Días hasta expiración (default: 7)
}

// AcceptInvitationRequest representa la petición para aceptar una invitación
type AcceptInvitationRequest struct {
	Token string `json:"token" validate:"required"`
}

// InvitationResponse representa la respuesta con información de invitación
type InvitationResponse struct {
	Invitation     Invitation `json:"invitation"`
	ScopeTemplates []string   `json:"scope_templates,omitempty"` // ✅ Available templates
}

// ToDTO convierte InvitationResponse a InvitationResponseDTO
func (ir *InvitationResponse) ToDTO() InvitationResponseDTO {
	return InvitationResponseDTO{
		Invitation:     ir.Invitation.ToDTO(),
		ScopeTemplates: ir.ScopeTemplates,
	}
}

// InvitationResponseDTO es la versión DTO de InvitationResponse
type InvitationResponseDTO struct {
	Invitation     InvitationDetailsDTO `json:"invitation"`
	ScopeTemplates []string             `json:"scope_templates,omitempty"`
}

// InvitationListResponse para listas de invitaciones
type InvitationListResponse struct {
	Invitations []InvitationResponse `json:"invitations"`
	Total       int                  `json:"total"`
}

// ToDTO convierte InvitationListResponse a InvitationListResponseDTO
func (ilr *InvitationListResponse) ToDTO() InvitationListResponseDTO {
	var invitationsDTO []InvitationResponseDTO
	for _, inv := range ilr.Invitations {
		invitationsDTO = append(invitationsDTO, inv.ToDTO())
	}

	return InvitationListResponseDTO{
		Invitations: invitationsDTO,
		Total:       ilr.Total,
	}
}

// InvitationListResponseDTO es la versión DTO de InvitationListResponse
type InvitationListResponseDTO struct {
	Invitations []InvitationResponseDTO `json:"invitations"`
	Total       int                     `json:"total"`
}

// RevokeInvitationRequest para revocar una invitación
type RevokeInvitationRequest struct {
	Reason string `json:"reason,omitempty"`
}

// ValidateInvitationRequest para validar un token de invitación
type ValidateInvitationRequest struct {
	Token string `json:"token" validate:"required"`
}

// ValidateInvitationResponse respuesta de validación de invitación
type ValidateInvitationResponse struct {
	Valid      bool                  `json:"valid"`
	Invitation *InvitationDetailsDTO `json:"invitation,omitempty"`
	Message    string                `json:"message,omitempty"`
}

// ============================================================================
// Helper Functions
// ============================================================================

// GenerateInvitationToken genera un token único para la invitación
func GenerateInvitationToken(byteLength int) (string, error) {
	bytes := make([]byte, byteLength)
	if _, err := rand.Read(bytes); err != nil {
		return "", errx.Wrap(err, "failed to generate invitation token", errx.TypeInternal)
	}
	return hex.EncodeToString(bytes), nil
}

func CalculateExpirationDate(daysFromNow int, defaultDays int) time.Time {
	if daysFromNow <= 0 {
		daysFromNow = defaultDays
	}
	return time.Now().AddDate(0, 0, daysFromNow)
}

// ============================================================================
// Error Registry - Errores específicos de Invitation
// ============================================================================

var ErrRegistry = errx.NewRegistry("INVITATION")

// Códigos de error
var (
	CodeInvitationNotFound        = ErrRegistry.Register("NOT_FOUND", errx.TypeNotFound, http.StatusNotFound, "Invitación no encontrada")
	CodeInvitationExpired         = ErrRegistry.Register("EXPIRED", errx.TypeBusiness, http.StatusGone, "Invitación expirada")
	CodeInvitationInvalid         = ErrRegistry.Register("INVALID", errx.TypeBusiness, http.StatusBadRequest, "Invitación inválida")
	CodeInvitationAlreadyAccepted = ErrRegistry.Register("ALREADY_ACCEPTED", errx.TypeBusiness, http.StatusConflict, "Invitación ya aceptada")
	CodeInvitationAlreadyRevoked  = ErrRegistry.Register("ALREADY_REVOKED", errx.TypeBusiness, http.StatusConflict, "Invitación ya revocada")
	CodeInvitationAlreadyExists   = ErrRegistry.Register("ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "Ya existe una invitación pendiente para este email")
	CodeUserAlreadyExists         = ErrRegistry.Register("USER_ALREADY_EXISTS", errx.TypeConflict, http.StatusConflict, "El usuario ya existe en este tenant")
	CodeInvalidScopeTemplate      = ErrRegistry.Register("INVALID_SCOPE_TEMPLATE", errx.TypeValidation, http.StatusBadRequest, "Plantilla de scopes no encontrada")
	CodeInvalidScopes             = ErrRegistry.Register("INVALID_SCOPES", errx.TypeValidation, http.StatusBadRequest, "Scopes inválidos")
)

// Helper functions para crear errores
func ErrInvitationNotFound() *errx.Error {
	return ErrRegistry.New(CodeInvitationNotFound)
}

func ErrInvitationExpired() *errx.Error {
	return ErrRegistry.New(CodeInvitationExpired)
}

func ErrInvitationInvalid() *errx.Error {
	return ErrRegistry.New(CodeInvitationInvalid)
}

func ErrInvitationAlreadyAccepted() *errx.Error {
	return ErrRegistry.New(CodeInvitationAlreadyAccepted)
}

func ErrInvitationAlreadyRevoked() *errx.Error {
	return ErrRegistry.New(CodeInvitationAlreadyRevoked)
}

func ErrInvitationAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeInvitationAlreadyExists)
}

func ErrUserAlreadyExists() *errx.Error {
	return ErrRegistry.New(CodeUserAlreadyExists)
}

func ErrInvalidScopeTemplate() *errx.Error {
	return ErrRegistry.New(CodeInvalidScopeTemplate)
}

func ErrInvalidScopes() *errx.Error {
	return ErrRegistry.New(CodeInvalidScopes)
}
package scopes

// ============================================================================
// DOMAIN-SPECIFIC SCOPES - ATS (Applicant Tracking System)
// ============================================================================

const ()

// DomainScopeCategories organizes domain-specific scopes
var DomainScopeCategories = map[string][]string{}

// DomainScopeDescriptions provides descriptions for domain scopes
var DomainScopeDescriptions = map[string]string{}

// DomainScopeGroups defines domain-specific role groupings
// Update DomainScopeGroups
var DomainScopeGroups = map[string][]string{}
package scopes

import "slices"

import "maps"

import "strings"

// ScopeCategories combines common and domain-specific categories
var ScopeCategories map[string][]string

// ScopeDescriptions combines common and domain-specific descriptions
var ScopeDescriptions map[string]string

// ScopeGroups combines common and domain-specific groups
var ScopeGroups map[string][]string

func init() {
	// Merge categories
	ScopeCategories = make(map[string][]string)
	maps.Copy(ScopeCategories, CommonScopeCategories)
	maps.Copy(ScopeCategories, DomainScopeCategories)

	// Merge descriptions
	ScopeDescriptions = make(map[string]string)
	maps.Copy(ScopeDescriptions, CommonScopeDescriptions)
	maps.Copy(ScopeDescriptions, DomainScopeDescriptions)

	// Merge groups
	ScopeGroups = make(map[string][]string)
	maps.Copy(ScopeGroups, CommonScopeGroups)
	maps.Copy(ScopeGroups, DomainScopeGroups)
}

// GetScopesByGroup returns all scopes for a given group
func GetScopesByGroup(group string) []string {
	if scopes, exists := ScopeGroups[group]; exists {
		return scopes
	}
	return []string{}
}

// GetScopeDescription returns the description for a given scope
func GetScopeDescription(scope string) string {
	if desc, exists := ScopeDescriptions[scope]; exists {
		return desc
	}
	return "No description available"
}

// GetAllScopes returns all defined scopes
func GetAllScopes() []string {
	allScopes := []string{}
	for _, scopes := range ScopeCategories {
		allScopes = append(allScopes, scopes...)
	}
	return allScopes
}

// GetCommonScopes returns only common/reusable scopes
func GetCommonScopes() []string {
	allScopes := []string{}
	for _, scopes := range CommonScopeCategories {
		allScopes = append(allScopes, scopes...)
	}
	return allScopes
}

// GetDomainScopes returns only domain-specific scopes
func GetDomainScopes() []string {
	allScopes := []string{}
	for _, scopes := range DomainScopeCategories {
		allScopes = append(allScopes, scopes...)
	}
	return allScopes
}

// ValidateScope checks if a scope is valid
func ValidateScope(scope string) bool {
	if scope == ScopeAll {
		return true
	}

	for _, scopes := range ScopeCategories {
		if slices.Contains(scopes, scope) {
			return true
		}
	}
	return false
}

// IsCommonScope checks if a scope is a common/reusable scope
func IsCommonScope(scope string) bool {
	for _, scopes := range CommonScopeCategories {
		if slices.Contains(scopes, scope) {
			return true
		}
	}
	return false
}

// IsDomainScope checks if a scope is a domain-specific scope
func IsDomainScope(scope string) bool {
	for _, scopes := range DomainScopeCategories {
		if slices.Contains(scopes, scope) {
			return true
		}
	}
	return false
}

// GetScopeCategory returns the category of a scope
func GetScopeCategory(scope string) string {
	for category, scopes := range ScopeCategories {
		if slices.Contains(scopes, scope) {
			return category
		}
	}
	return "Unknown"
}

// ExpandWildcardScope expands a wildcard scope to all matching scopes
// e.g., "jobs:*" -> ["jobs:read", "jobs:write", "jobs:delete", ...]
func ExpandWildcardScope(wildcardScope string) []string {
	if wildcardScope == ScopeAll {
		return GetAllScopes()
	}

	if !strings.HasSuffix(wildcardScope, ":*") {
		return []string{wildcardScope}
	}

	prefix := strings.TrimSuffix(wildcardScope, ":*")
	expanded := []string{}

	for _, scopes := range ScopeCategories {
		for _, scope := range scopes {
			if strings.HasPrefix(scope, prefix+":") {
				expanded = append(expanded, scope)
			}
		}
	}

	return expanded
}
package scopes

// ============================================================================
// COMMON SCOPES - Reusable across any project
// ============================================================================

const (
	// Super scope - full access to everything
	ScopeAll = "*"

	// Admin scopes
	ScopeAdminAll   = "admin:*"
	ScopeAdminRead  = "admin:read"
	ScopeAdminWrite = "admin:write"

	// User management scopes
	ScopeUsersAll    = "users:*"
	ScopeUsersRead   = "users:read"
	ScopeUsersWrite  = "users:write"
	ScopeUsersDelete = "users:delete"
	ScopeUsersInvite = "users:invite"

	// Role management scopes
	ScopeRolesAll    = "roles:*"
	ScopeRolesRead   = "roles:read"
	ScopeRolesWrite  = "roles:write"
	ScopeRolesDelete = "roles:delete"
	ScopeRolesAssign = "roles:assign"

	// Tenant management scopes
	ScopeTenantsAll    = "tenants:*"
	ScopeTenantsRead   = "tenants:read"
	ScopeTenantsWrite  = "tenants:write"
	ScopeTenantsDelete = "tenants:delete"
	ScopeTenantsConfig = "tenants:config"

	// API Key scopes
	ScopeAPIKeysAll    = "api_keys:*"
	ScopeAPIKeysRead   = "api_keys:read"
	ScopeAPIKeysWrite  = "api_keys:write"
	ScopeAPIKeysDelete = "api_keys:delete"
	ScopeAPIKeysRevoke = "api_keys:revoke"

	// Settings scopes
	ScopeSettingsAll   = "settings:*"
	ScopeSettingsRead  = "settings:read"
	ScopeSettingsWrite = "settings:write"

	// Audit log scopes
	ScopeAuditAll  = "audit:*"
	ScopeAuditRead = "audit:read"

	// Reports/Analytics scopes (generic)
	ScopeReportsAll         = "reports:*"
	ScopeReportsView        = "reports:view"
	ScopeReportsExport      = "reports:export"
	ScopeReportsCreate      = "reports:create"
	ScopeAnalyticsDashboard = "analytics:dashboard"

	// Integration scopes (generic for any external integrations)
	ScopeIntegrationsAll    = "integrations:*"
	ScopeIntegrationsRead   = "integrations:read"
	ScopeIntegrationsWrite  = "integrations:write"
	ScopeIntegrationsDelete = "integrations:delete"
	ScopeIntegrationsTest   = "integrations:test"

	// Notification scopes
	ScopeNotificationsAll   = "notifications:*"
	ScopeNotificationsRead  = "notifications:read"
	ScopeNotificationsSend  = "notifications:send"
	ScopeNotificationsWrite = "notifications:write"

	// Template scopes (generic templates)
	ScopeTemplatesAll    = "templates:*"
	ScopeTemplatesRead   = "templates:read"
	ScopeTemplatesWrite  = "templates:write"
	ScopeTemplatesDelete = "templates:delete"
)

// CommonScopeCategories organizes common scopes by domain
var CommonScopeCategories = map[string][]string{
	"Administration": {
		ScopeAll,
		ScopeAdminAll,
		ScopeAdminRead,
		ScopeAdminWrite,
	},
	"Users": {
		ScopeUsersAll,
		ScopeUsersRead,
		ScopeUsersWrite,
		ScopeUsersDelete,
		ScopeUsersInvite,
	},
	"Roles": {
		ScopeRolesAll,
		ScopeRolesRead,
		ScopeRolesWrite,
		ScopeRolesDelete,
		ScopeRolesAssign,
	},
	"Tenants": {
		ScopeTenantsAll,
		ScopeTenantsRead,
		ScopeTenantsWrite,
		ScopeTenantsDelete,
		ScopeTenantsConfig,
	},
	"API Keys": {
		ScopeAPIKeysAll,
		ScopeAPIKeysRead,
		ScopeAPIKeysWrite,
		ScopeAPIKeysDelete,
		ScopeAPIKeysRevoke,
	},
	"Settings": {
		ScopeSettingsAll,
		ScopeSettingsRead,
		ScopeSettingsWrite,
	},
	"Audit": {
		ScopeAuditAll,
		ScopeAuditRead,
	},
	"Reports & Analytics": {
		ScopeReportsAll,
		ScopeReportsView,
		ScopeReportsExport,
		ScopeReportsCreate,
		ScopeAnalyticsDashboard,
	},
	"Integrations": {
		ScopeIntegrationsAll,
		ScopeIntegrationsRead,
		ScopeIntegrationsWrite,
		ScopeIntegrationsDelete,
		ScopeIntegrationsTest,
	},
	"Notifications": {
		ScopeNotificationsAll,
		ScopeNotificationsRead,
		ScopeNotificationsSend,
		ScopeNotificationsWrite,
	},
	"Templates": {
		ScopeTemplatesAll,
		ScopeTemplatesRead,
		ScopeTemplatesWrite,
		ScopeTemplatesDelete,
	},
}

// CommonScopeDescriptions provides human-readable descriptions
var CommonScopeDescriptions = map[string]string{
	// Super admin
	ScopeAll: "Full access to all system resources",

	// Admin
	ScopeAdminAll:   "Full administrative access",
	ScopeAdminRead:  "View administrative settings",
	ScopeAdminWrite: "Modify administrative settings",

	// Users
	ScopeUsersAll:    "Full access to user management",
	ScopeUsersRead:   "View users",
	ScopeUsersWrite:  "Create and edit users",
	ScopeUsersDelete: "Delete users",
	ScopeUsersInvite: "Invite new users",

	// Roles
	ScopeRolesAll:    "Full access to role management",
	ScopeRolesRead:   "View roles",
	ScopeRolesWrite:  "Create and edit roles",
	ScopeRolesDelete: "Delete roles",
	ScopeRolesAssign: "Assign roles to users",

	// Tenants
	ScopeTenantsAll:    "Full access to tenant management",
	ScopeTenantsRead:   "View tenants",
	ScopeTenantsWrite:  "Create and edit tenants",
	ScopeTenantsDelete: "Delete tenants",
	ScopeTenantsConfig: "Manage tenant configuration",

	// API Keys
	ScopeAPIKeysAll:    "Full access to API key management",
	ScopeAPIKeysRead:   "View API keys",
	ScopeAPIKeysWrite:  "Create and edit API keys",
	ScopeAPIKeysDelete: "Delete API keys",
	ScopeAPIKeysRevoke: "Revoke API keys",

	// Settings
	ScopeSettingsAll:   "Full access to settings",
	ScopeSettingsRead:  "View settings",
	ScopeSettingsWrite: "Modify settings",

	// Audit
	ScopeAuditAll:  "Full access to audit logs",
	ScopeAuditRead: "View audit logs",

	// Reports
	ScopeReportsAll:         "Full access to reporting",
	ScopeReportsView:        "View reports",
	ScopeReportsExport:      "Export reports",
	ScopeReportsCreate:      "Create custom reports",
	ScopeAnalyticsDashboard: "Access analytics dashboard",

	// Integrations
	ScopeIntegrationsAll:    "Full access to integrations",
	ScopeIntegrationsRead:   "View integrations",
	ScopeIntegrationsWrite:  "Create and edit integrations",
	ScopeIntegrationsDelete: "Delete integrations",
	ScopeIntegrationsTest:   "Test integrations",

	// Notifications
	ScopeNotificationsAll:   "Full access to notifications",
	ScopeNotificationsRead:  "View notifications",
	ScopeNotificationsSend:  "Send notifications",
	ScopeNotificationsWrite: "Configure notifications",

	// Templates
	ScopeTemplatesAll:    "Full access to templates",
	ScopeTemplatesRead:   "View templates",
	ScopeTemplatesWrite:  "Create and edit templates",
	ScopeTemplatesDelete: "Delete templates",
}

// CommonScopeGroups defines common role groupings
var CommonScopeGroups = map[string][]string{
	"super_admin": {
		ScopeAll,
	},
	"platform_admin": {
		ScopeAdminAll,
		ScopeUsersAll,
		ScopeRolesAll,
		ScopeTenantsAll,
		ScopeSettingsAll,
		ScopeAuditRead,
		ScopeAPIKeysAll,
	},
	"tenant_admin": {
		ScopeUsersAll,
		ScopeRolesAll,
		ScopeSettingsAll,
		ScopeAPIKeysAll,
		ScopeTenantsRead,
		ScopeTenantsConfig,
	},
	"user_manager": {
		ScopeUsersAll,
		ScopeRolesRead,
		ScopeRolesAssign,
		ScopeUsersInvite,
	},
	"analyst": {
		ScopeReportsAll,
		ScopeAnalyticsDashboard,
		ScopeAuditRead,
	},
	"api_admin": {
		ScopeAPIKeysAll,
		ScopeIntegrationsAll,
	},
	"settings_admin": {
		ScopeSettingsAll,
		ScopeTenantsConfig,
		ScopeTemplatesAll,
		ScopeNotificationsAll,
	},
	"auditor": {
		ScopeAuditRead,
		ScopeUsersRead,
		ScopeRolesRead,
		ScopeTenantsRead,
	},
	"viewer": {
		ScopeUsersRead,
		ScopeRolesRead,
		ScopeTenantsRead,
		ScopeReportsView,
	},
}
